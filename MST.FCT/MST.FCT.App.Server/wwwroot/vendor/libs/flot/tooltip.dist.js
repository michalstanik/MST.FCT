(function(e, a) { for(var i in a) e[i] = a[i]; }(window, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./wwwroot/vendor/libs/flot/tooltip.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./wwwroot/vendor/libs/flot/tooltip.js":
/*!*********************************************!*\
  !*** ./wwwroot/vendor/libs/flot/tooltip.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// REPO: https://github.com/krzysu/flot.tooltip\n\n/*\n * jquery.flot.tooltip\n * \n * description: easy-to-use tooltips for Flot charts\n * version: 0.9.0\n * authors: Krzysztof Urbas @krzysu [myviews.pl],Evan Steinkerchner @Roundaround\n * website: https://github.com/krzysu/flot.tooltip\n * \n * build on 2016-07-26\n * released under MIT License, 2012\n*/\n(function ($) {\n  // plugin options, default values\n  var defaultOptions = {\n    tooltip: {\n      show: false,\n      cssClass: \"flotTip\",\n      content: \"%s | X: %x | Y: %y\",\n      // allowed templates are:\n      // %s -> series label,\n      // %c -> series color,\n      // %lx -> x axis label (requires flot-axislabels plugin https://github.com/markrcote/flot-axislabels),\n      // %ly -> y axis label (requires flot-axislabels plugin https://github.com/markrcote/flot-axislabels),\n      // %x -> X value,\n      // %y -> Y value,\n      // %x.2 -> precision of X value,\n      // %p -> percent\n      // %n -> value (not percent) of pie chart\n      xDateFormat: null,\n      yDateFormat: null,\n      monthNames: null,\n      dayNames: null,\n      shifts: {\n        x: 10,\n        y: 20\n      },\n      defaultTheme: true,\n      snap: true,\n      lines: false,\n      clickTips: false,\n      // callbacks\n      onHover: function onHover(flotItem, $tooltipEl) {},\n      $compat: false\n    }\n  }; // dummy default options object for legacy code (<0.8.5) - is deleted later\n\n  defaultOptions.tooltipOpts = defaultOptions.tooltip; // object\n\n  var FlotTooltip = function FlotTooltip(plot) {\n    // variables\n    this.tipPosition = {\n      x: 0,\n      y: 0\n    };\n    this.init(plot);\n  }; // main plugin function\n\n\n  FlotTooltip.prototype.init = function (plot) {\n    var that = this; // detect other flot plugins\n\n    var plotPluginsLength = $.plot.plugins.length;\n    this.plotPlugins = [];\n\n    if (plotPluginsLength) {\n      for (var p = 0; p < plotPluginsLength; p++) {\n        this.plotPlugins.push($.plot.plugins[p].name);\n      }\n    }\n\n    plot.hooks.bindEvents.push(function (plot, eventHolder) {\n      // get plot options\n      that.plotOptions = plot.getOptions(); // for legacy (<0.8.5) implementations\n\n      if (typeof that.plotOptions.tooltip === 'boolean') {\n        that.plotOptions.tooltipOpts.show = that.plotOptions.tooltip;\n        that.plotOptions.tooltip = that.plotOptions.tooltipOpts;\n        delete that.plotOptions.tooltipOpts;\n      } // if not enabled return\n\n\n      if (that.plotOptions.tooltip.show === false || typeof that.plotOptions.tooltip.show === 'undefined') return; // shortcut to access tooltip options\n\n      that.tooltipOptions = that.plotOptions.tooltip;\n\n      if (that.tooltipOptions.$compat) {\n        that.wfunc = 'width';\n        that.hfunc = 'height';\n      } else {\n        that.wfunc = 'innerWidth';\n        that.hfunc = 'innerHeight';\n      } // create tooltip DOM element\n\n\n      var $tip = that.getDomElement(); // bind event\n\n      $(plot.getPlaceholder()).bind(\"plothover\", plothover);\n\n      if (that.tooltipOptions.clickTips) {\n        $(plot.getPlaceholder()).bind(\"plotclick\", plotclick);\n      }\n\n      that.clickmode = false;\n      $(eventHolder).bind('mousemove', mouseMove);\n    });\n    plot.hooks.shutdown.push(function (plot, eventHolder) {\n      $(plot.getPlaceholder()).unbind(\"plothover\", plothover);\n      $(plot.getPlaceholder()).unbind(\"plotclick\", plotclick);\n      plot.removeTooltip();\n      $(eventHolder).unbind(\"mousemove\", mouseMove);\n    });\n\n    function mouseMove(e) {\n      var pos = {};\n      pos.x = e.pageX;\n      pos.y = e.pageY;\n      plot.setTooltipPosition(pos);\n    }\n    /**\n     *  open the tooltip (if not already open) and freeze it on the current position till the next click\n     */\n\n\n    function plotclick(event, pos, item) {\n      if (!that.clickmode) {\n        // it is the click activating the clicktip\n        plothover(event, pos, item);\n\n        if (that.getDomElement().is(\":visible\")) {\n          $(plot.getPlaceholder()).unbind(\"plothover\", plothover);\n          that.clickmode = true;\n        }\n      } else {\n        // it is the click deactivating the clicktip\n        $(plot.getPlaceholder()).bind(\"plothover\", plothover);\n        plot.hideTooltip();\n        that.clickmode = false;\n      }\n    }\n\n    function plothover(event, pos, item) {\n      // Simple distance formula.\n      var lineDistance = function lineDistance(p1x, p1y, p2x, p2y) {\n        return Math.sqrt((p2x - p1x) * (p2x - p1x) + (p2y - p1y) * (p2y - p1y));\n      }; // Here is some voodoo magic for determining the distance to a line form a given point {x, y}.\n\n\n      var dotLineLength = function dotLineLength(x, y, x0, y0, x1, y1, o) {\n        if (o && !(o = function (x, y, x0, y0, x1, y1) {\n          if (typeof x0 !== 'undefined') return {\n            x: x0,\n            y: y\n          };else if (typeof y0 !== 'undefined') return {\n            x: x,\n            y: y0\n          };\n          var left,\n              tg = -1 / ((y1 - y0) / (x1 - x0));\n          return {\n            x: left = (x1 * (x * tg - y + y0) + x0 * (x * -tg + y - y1)) / (tg * (x1 - x0) + y0 - y1),\n            y: tg * left - tg * x + y\n          };\n        }(x, y, x0, y0, x1, y1), o.x >= Math.min(x0, x1) && o.x <= Math.max(x0, x1) && o.y >= Math.min(y0, y1) && o.y <= Math.max(y0, y1))) {\n          var l1 = lineDistance(x, y, x0, y0),\n              l2 = lineDistance(x, y, x1, y1);\n          return l1 > l2 ? l2 : l1;\n        } else {\n          var a = y0 - y1,\n              b = x1 - x0,\n              c = x0 * y1 - y0 * x1;\n          return Math.abs(a * x + b * y + c) / Math.sqrt(a * a + b * b);\n        }\n      };\n\n      if (item) {\n        plot.showTooltip(item, that.tooltipOptions.snap ? item : pos);\n      } else if (that.plotOptions.series.lines.show && that.tooltipOptions.lines === true) {\n        var maxDistance = that.plotOptions.grid.mouseActiveRadius;\n        var closestTrace = {\n          distance: maxDistance + 1\n        };\n        var ttPos = pos;\n        $.each(plot.getData(), function (i, series) {\n          var xBeforeIndex = 0,\n              xAfterIndex = -1; // Our search here assumes our data is sorted via the x-axis.\n          // TODO: Improve efficiency somehow - search smaller sets of data.\n\n          for (var j = 1; j < series.data.length; j++) {\n            if (series.data[j - 1][0] <= pos.x && series.data[j][0] >= pos.x) {\n              xBeforeIndex = j - 1;\n              xAfterIndex = j;\n            }\n          }\n\n          if (xAfterIndex === -1) {\n            plot.hideTooltip();\n            return;\n          }\n\n          var pointPrev = {\n            x: series.data[xBeforeIndex][0],\n            y: series.data[xBeforeIndex][1]\n          },\n              pointNext = {\n            x: series.data[xAfterIndex][0],\n            y: series.data[xAfterIndex][1]\n          };\n          var distToLine = dotLineLength(series.xaxis.p2c(pos.x), series.yaxis.p2c(pos.y), series.xaxis.p2c(pointPrev.x), series.yaxis.p2c(pointPrev.y), series.xaxis.p2c(pointNext.x), series.yaxis.p2c(pointNext.y), false);\n\n          if (distToLine < closestTrace.distance) {\n            var closestIndex = lineDistance(pointPrev.x, pointPrev.y, pos.x, pos.y) < lineDistance(pos.x, pos.y, pointNext.x, pointNext.y) ? xBeforeIndex : xAfterIndex;\n            var pointSize = series.datapoints.pointsize; // Calculate the point on the line vertically closest to our cursor.\n\n            var pointOnLine = [pos.x, pointPrev.y + (pointNext.y - pointPrev.y) * ((pos.x - pointPrev.x) / (pointNext.x - pointPrev.x))];\n            var item = {\n              datapoint: pointOnLine,\n              dataIndex: closestIndex,\n              series: series,\n              seriesIndex: i\n            };\n            closestTrace = {\n              distance: distToLine,\n              item: item\n            };\n\n            if (that.tooltipOptions.snap) {\n              ttPos = {\n                pageX: series.xaxis.p2c(pointOnLine[0]),\n                pageY: series.yaxis.p2c(pointOnLine[1])\n              };\n            }\n          }\n        });\n        if (closestTrace.distance < maxDistance + 1) plot.showTooltip(closestTrace.item, ttPos);else plot.hideTooltip();\n      } else {\n        plot.hideTooltip();\n      }\n    } // Quick little function for setting the tooltip position.\n\n\n    plot.setTooltipPosition = function (pos) {\n      var $tip = that.getDomElement();\n      var totalTipWidth = $tip.outerWidth() + that.tooltipOptions.shifts.x;\n      var totalTipHeight = $tip.outerHeight() + that.tooltipOptions.shifts.y;\n\n      if (pos.x - $(window).scrollLeft() > $(window)[that.wfunc]() - totalTipWidth) {\n        pos.x -= totalTipWidth;\n        pos.x = Math.max(pos.x, 0);\n      }\n\n      if (pos.y - $(window).scrollTop() > $(window)[that.hfunc]() - totalTipHeight) {\n        pos.y -= totalTipHeight;\n      }\n      /*\n         The section applies the new positioning ONLY if pos.x and pos.y\n         are numbers. If they are undefined or not a number, use the last\n         known numerical position. This hack fixes a bug that kept pie\n         charts from keeping their tooltip positioning.\n       */\n\n\n      if (isNaN(pos.x)) {\n        that.tipPosition.x = that.tipPosition.xPrev;\n      } else {\n        that.tipPosition.x = pos.x;\n        that.tipPosition.xPrev = pos.x;\n      }\n\n      if (isNaN(pos.y)) {\n        that.tipPosition.y = that.tipPosition.yPrev;\n      } else {\n        that.tipPosition.y = pos.y;\n        that.tipPosition.yPrev = pos.y;\n      }\n    }; // Quick little function for showing the tooltip.\n\n\n    plot.showTooltip = function (target, position, targetPosition) {\n      var $tip = that.getDomElement(); // convert tooltip content template to real tipText\n\n      var tipText = that.stringFormat(that.tooltipOptions.content, target);\n      if (tipText === '') return;\n      $tip.html(tipText);\n      plot.setTooltipPosition({\n        x: that.tipPosition.x,\n        y: that.tipPosition.y\n      });\n      $tip.css({\n        left: that.tipPosition.x + that.tooltipOptions.shifts.x,\n        top: that.tipPosition.y + that.tooltipOptions.shifts.y\n      }).show(); // run callback\n\n      if (typeof that.tooltipOptions.onHover === 'function') {\n        that.tooltipOptions.onHover(target, $tip);\n      }\n    }; // Quick little function for hiding the tooltip.\n\n\n    plot.hideTooltip = function () {\n      that.getDomElement().hide().html('');\n    };\n\n    plot.removeTooltip = function () {\n      that.getDomElement().remove();\n    };\n  };\n  /**\n   * get or create tooltip DOM element\n   * @return jQuery object\n   */\n\n\n  FlotTooltip.prototype.getDomElement = function () {\n    var $tip = $('<div>');\n\n    if (this.tooltipOptions && this.tooltipOptions.cssClass) {\n      $tip = $('.' + this.tooltipOptions.cssClass);\n\n      if ($tip.length === 0) {\n        $tip = $('<div />').addClass(this.tooltipOptions.cssClass);\n        $tip.appendTo('body').hide().css({\n          position: 'absolute'\n        });\n\n        if (this.tooltipOptions.defaultTheme) {\n          $tip.css({\n            'background': '#fff',\n            'z-index': '1040',\n            'padding': '0.4em 0.6em',\n            'border-radius': '0.5em',\n            'font-size': '0.8em',\n            'border': '1px solid #111',\n            'display': 'none',\n            'white-space': 'nowrap'\n          });\n        }\n      }\n    }\n\n    return $tip;\n  };\n  /**\n   * core function, create tooltip content\n   * @param  {string} content - template with tooltip content\n   * @param  {object} item - Flot item\n   * @return {string} real tooltip content for current item\n   */\n\n\n  FlotTooltip.prototype.stringFormat = function (content, item) {\n    var percentPattern = /%p\\.{0,1}(\\d{0,})/;\n    var seriesPattern = /%s/;\n    var colorPattern = /%c/;\n    var xLabelPattern = /%lx/; // requires flot-axislabels plugin https://github.com/markrcote/flot-axislabels, will be ignored if plugin isn't loaded\n\n    var yLabelPattern = /%ly/; // requires flot-axislabels plugin https://github.com/markrcote/flot-axislabels, will be ignored if plugin isn't loaded\n\n    var xPattern = /%x\\.{0,1}(\\d{0,})/;\n    var yPattern = /%y\\.{0,1}(\\d{0,})/;\n    var xPatternWithoutPrecision = \"%x\";\n    var yPatternWithoutPrecision = \"%y\";\n    var customTextPattern = \"%ct\";\n    var nPiePattern = \"%n\";\n    var x, y, customText, p, n; // for threshold plugin we need to read data from different place\n\n    if (typeof item.series.threshold !== \"undefined\") {\n      x = item.datapoint[0];\n      y = item.datapoint[1];\n      customText = item.datapoint[2];\n    } // for CurvedLines plugin we need to read data from different place\n    else if (typeof item.series.curvedLines !== \"undefined\") {\n        x = item.datapoint[0];\n        y = item.datapoint[1];\n      } else if (typeof item.series.lines !== \"undefined\" && item.series.lines.steps) {\n        x = item.series.datapoints.points[item.dataIndex * 2];\n        y = item.series.datapoints.points[item.dataIndex * 2 + 1]; // TODO: where to find custom text in this variant?\n\n        customText = \"\";\n      } else {\n        x = item.series.data[item.dataIndex][0];\n        y = item.series.data[item.dataIndex][1];\n        customText = item.series.data[item.dataIndex][2];\n      } // I think this is only in case of threshold plugin\n\n\n    if (item.series.label === null && item.series.originSeries) {\n      item.series.label = item.series.originSeries.label;\n    } // if it is a function callback get the content string\n\n\n    if (typeof content === 'function') {\n      content = content(item.series.label, x, y, item);\n    } // the case where the passed content is equal to false\n\n\n    if (typeof content === 'boolean' && !content) {\n      return '';\n    }\n    /* replacement of %ct and other multi-character templates must\n       precede the replacement of single-character templates\n       to avoid conflict between '%c' and '%ct'  and similar substrings\n    */\n\n\n    if (customText) {\n      content = content.replace(customTextPattern, customText);\n    } // percent match for pie charts and stacked percent\n\n\n    if (typeof item.series.percent !== 'undefined') {\n      p = item.series.percent;\n    } else if (typeof item.series.percents !== 'undefined') {\n      p = item.series.percents[item.dataIndex];\n    }\n\n    if (typeof p === 'number') {\n      content = this.adjustValPrecision(percentPattern, content, p);\n    } // replace %n with number of items represented by slice in pie charts\n\n\n    if (item.series.hasOwnProperty('pie')) {\n      if (typeof item.series.data[0][1] !== 'undefined') {\n        n = item.series.data[0][1];\n      }\n    }\n\n    if (typeof n === 'number') {\n      content = content.replace(nPiePattern, n);\n    } // series match\n\n\n    if (typeof item.series.label !== 'undefined') {\n      content = content.replace(seriesPattern, item.series.label);\n    } else {\n      //remove %s if label is undefined\n      content = content.replace(seriesPattern, \"\");\n    } // color match\n\n\n    if (typeof item.series.color !== 'undefined') {\n      content = content.replace(colorPattern, item.series.color);\n    } else {\n      //remove %s if color is undefined\n      content = content.replace(colorPattern, \"\");\n    } // x axis label match\n\n\n    if (this.hasAxisLabel('xaxis', item)) {\n      content = content.replace(xLabelPattern, item.series.xaxis.options.axisLabel);\n    } else {\n      //remove %lx if axis label is undefined or axislabels plugin not present\n      content = content.replace(xLabelPattern, \"\");\n    } // y axis label match\n\n\n    if (this.hasAxisLabel('yaxis', item)) {\n      content = content.replace(yLabelPattern, item.series.yaxis.options.axisLabel);\n    } else {\n      //remove %ly if axis label is undefined or axislabels plugin not present\n      content = content.replace(yLabelPattern, \"\");\n    } // time mode axes with custom dateFormat\n\n\n    if (this.isTimeMode('xaxis', item) && this.isXDateFormat(item)) {\n      content = content.replace(xPattern, this.timestampToDate(x, this.tooltipOptions.xDateFormat, item.series.xaxis.options));\n    }\n\n    if (this.isTimeMode('yaxis', item) && this.isYDateFormat(item)) {\n      content = content.replace(yPattern, this.timestampToDate(y, this.tooltipOptions.yDateFormat, item.series.yaxis.options));\n    } // set precision if defined\n\n\n    if (typeof x === 'number') {\n      content = this.adjustValPrecision(xPattern, content, x);\n    }\n\n    if (typeof y === 'number') {\n      content = this.adjustValPrecision(yPattern, content, y);\n    } // change x from number to given label, if given\n\n\n    if (typeof item.series.xaxis.ticks !== 'undefined') {\n      var ticks;\n\n      if (this.hasRotatedXAxisTicks(item)) {\n        // xaxis.ticks will be an empty array if tickRotor is being used, but the values are available in rotatedTicks\n        ticks = 'rotatedTicks';\n      } else {\n        ticks = 'ticks';\n      } // see https://github.com/krzysu/flot.tooltip/issues/65\n\n\n      var tickIndex = item.dataIndex + item.seriesIndex;\n\n      for (var xIndex in item.series.xaxis[ticks]) {\n        if (item.series.xaxis[ticks].hasOwnProperty(tickIndex) && !this.isTimeMode('xaxis', item)) {\n          var valueX = this.isCategoriesMode('xaxis', item) ? item.series.xaxis[ticks][tickIndex].label : item.series.xaxis[ticks][tickIndex].v;\n\n          if (valueX === x) {\n            content = content.replace(xPattern, item.series.xaxis[ticks][tickIndex].label.replace(/\\$/g, '$$$$'));\n          }\n        }\n      }\n    } // change y from number to given label, if given\n\n\n    if (typeof item.series.yaxis.ticks !== 'undefined') {\n      for (var yIndex in item.series.yaxis.ticks) {\n        if (item.series.yaxis.ticks.hasOwnProperty(yIndex)) {\n          var valueY = this.isCategoriesMode('yaxis', item) ? item.series.yaxis.ticks[yIndex].label : item.series.yaxis.ticks[yIndex].v;\n\n          if (valueY === y) {\n            content = content.replace(yPattern, item.series.yaxis.ticks[yIndex].label.replace(/\\$/g, '$$$$'));\n          }\n        }\n      }\n    } // if no value customization, use tickFormatter by default\n\n\n    if (typeof item.series.xaxis.tickFormatter !== 'undefined') {\n      //escape dollar\n      content = content.replace(xPatternWithoutPrecision, item.series.xaxis.tickFormatter(x, item.series.xaxis).replace(/\\$/g, '$$'));\n    }\n\n    if (typeof item.series.yaxis.tickFormatter !== 'undefined') {\n      //escape dollar\n      content = content.replace(yPatternWithoutPrecision, item.series.yaxis.tickFormatter(y, item.series.yaxis).replace(/\\$/g, '$$'));\n    }\n\n    return content;\n  }; // helpers just for readability\n\n\n  FlotTooltip.prototype.isTimeMode = function (axisName, item) {\n    return typeof item.series[axisName].options.mode !== 'undefined' && item.series[axisName].options.mode === 'time';\n  };\n\n  FlotTooltip.prototype.isXDateFormat = function (item) {\n    return typeof this.tooltipOptions.xDateFormat !== 'undefined' && this.tooltipOptions.xDateFormat !== null;\n  };\n\n  FlotTooltip.prototype.isYDateFormat = function (item) {\n    return typeof this.tooltipOptions.yDateFormat !== 'undefined' && this.tooltipOptions.yDateFormat !== null;\n  };\n\n  FlotTooltip.prototype.isCategoriesMode = function (axisName, item) {\n    return typeof item.series[axisName].options.mode !== 'undefined' && item.series[axisName].options.mode === 'categories';\n  }; //\n\n\n  FlotTooltip.prototype.timestampToDate = function (tmst, dateFormat, options) {\n    var theDate = $.plot.dateGenerator(tmst, options);\n    return $.plot.formatDate(theDate, dateFormat, this.tooltipOptions.monthNames, this.tooltipOptions.dayNames);\n  }; //\n\n\n  FlotTooltip.prototype.adjustValPrecision = function (pattern, content, value) {\n    var precision;\n    var matchResult = content.match(pattern);\n\n    if (matchResult !== null) {\n      if (RegExp.$1 !== '') {\n        precision = RegExp.$1;\n        value = value.toFixed(precision); // only replace content if precision exists, in other case use thickformater\n\n        content = content.replace(pattern, value);\n      }\n    }\n\n    return content;\n  }; // other plugins detection below\n  // check if flot-axislabels plugin (https://github.com/markrcote/flot-axislabels) is used and that an axis label is given\n\n\n  FlotTooltip.prototype.hasAxisLabel = function (axisName, item) {\n    return $.inArray('axisLabels', this.plotPlugins) !== -1 && typeof item.series[axisName].options.axisLabel !== 'undefined' && item.series[axisName].options.axisLabel.length > 0;\n  }; // check whether flot-tickRotor, a plugin which allows rotation of X-axis ticks, is being used\n\n\n  FlotTooltip.prototype.hasRotatedXAxisTicks = function (item) {\n    return $.inArray('tickRotor', this.plotPlugins) !== -1 && typeof item.series.xaxis.rotatedTicks !== 'undefined';\n  }; //\n\n\n  var init = function init(plot) {\n    new FlotTooltip(plot);\n  }; // define Flot plugin\n\n\n  $.plot.plugins.push({\n    init: init,\n    options: defaultOptions,\n    name: 'tooltip',\n    version: '0.8.5'\n  });\n})(jQuery);\n\n//# sourceURL=webpack:///./wwwroot/vendor/libs/flot/tooltip.js?");

/***/ })

/******/ })));