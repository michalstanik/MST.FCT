(function(e, a) { for(var i in a) e[i] = a[i]; }(window, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./wwwroot/vendor/libs/shepherd/shepherd.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/shepherd.js/dist/js/shepherd.js":
/*!******************************************************!*\
  !*** ./node_modules/shepherd.js/dist/js/shepherd.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*! shepherd.js 7.1.5 */\n(function (global, factory) {\n  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);\n})(this, function () {\n  'use strict';\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n  /**\n   * Checks if `value` is classified as an `HTMLElement`.\n   * @param {*} value The param to check if it is an HTMLElement\n   */\n\n\n  function isElement(value) {\n    return value instanceof HTMLElement;\n  }\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   * @param {*} value The param to check if it is a function\n   */\n\n\n  function isFunction(value) {\n    return typeof value === 'function';\n  }\n  /**\n   * Checks if `value` is classified as a `String` object.\n   * @param {*} value The param to check if it is a string\n   */\n\n\n  function isString(value) {\n    return typeof value === 'string';\n  }\n  /**\n   * Checks if `value` is undefined.\n   * @param {*} value The param to check if it is undefined\n   */\n\n\n  function isUndefined(value) {\n    return value === undefined;\n  }\n\n  var Evented = /*#__PURE__*/function () {\n    function Evented() {}\n\n    var _proto = Evented.prototype;\n\n    _proto.on = function on(event, handler, ctx, once) {\n      if (once === void 0) {\n        once = false;\n      }\n\n      if (isUndefined(this.bindings)) {\n        this.bindings = {};\n      }\n\n      if (isUndefined(this.bindings[event])) {\n        this.bindings[event] = [];\n      }\n\n      this.bindings[event].push({\n        handler: handler,\n        ctx: ctx,\n        once: once\n      });\n      return this;\n    };\n\n    _proto.once = function once(event, handler, ctx) {\n      return this.on(event, handler, ctx, true);\n    };\n\n    _proto.off = function off(event, handler) {\n      var _this = this;\n\n      if (isUndefined(this.bindings) || isUndefined(this.bindings[event])) {\n        return this;\n      }\n\n      if (isUndefined(handler)) {\n        delete this.bindings[event];\n      } else {\n        this.bindings[event].forEach(function (binding, index) {\n          if (binding.handler === handler) {\n            _this.bindings[event].splice(index, 1);\n          }\n        });\n      }\n\n      return this;\n    };\n\n    _proto.trigger = function trigger(event) {\n      var _this2 = this;\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (!isUndefined(this.bindings) && this.bindings[event]) {\n        this.bindings[event].forEach(function (binding, index) {\n          var ctx = binding.ctx,\n              handler = binding.handler,\n              once = binding.once;\n          var context = ctx || _this2;\n          handler.apply(context, args);\n\n          if (once) {\n            _this2.bindings[event].splice(index, 1);\n          }\n        });\n      }\n\n      return this;\n    };\n\n    return Evented;\n  }();\n  /**\n   * Binds all the methods on a JS Class to the `this` context of the class.\n   * Adapted from https://github.com/sindresorhus/auto-bind\n   * @param {object} self The `this` context of the class\n   * @return {object} The `this` context of the class\n   */\n\n\n  function autoBind(self) {\n    var keys = Object.getOwnPropertyNames(self.constructor.prototype);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var val = self[key];\n\n      if (key !== 'constructor' && typeof val === 'function') {\n        self[key] = val.bind(self);\n      }\n    }\n\n    return self;\n  }\n  /**\n   * Sets up the handler to determine if we should advance the tour\n   * @param {string} selector\n   * @param {Step} step The step instance\n   * @return {Function}\n   * @private\n   */\n\n\n  function _setupAdvanceOnHandler(selector, step) {\n    return function (event) {\n      if (step.isOpen()) {\n        var targetIsEl = step.el && event.currentTarget === step.el;\n        var targetIsSelector = !isUndefined(selector) && event.currentTarget.matches(selector);\n\n        if (targetIsSelector || targetIsEl) {\n          step.tour.next();\n        }\n      }\n    };\n  }\n  /**\n   * Bind the event handler for advanceOn\n   * @param {Step} step The step instance\n   */\n\n\n  function bindAdvance(step) {\n    // An empty selector matches the step element\n    var _ref = step.options.advanceOn || {},\n        event = _ref.event,\n        selector = _ref.selector;\n\n    if (event) {\n      var handler = _setupAdvanceOnHandler(selector, step); // TODO: this should also bind/unbind on show/hide\n\n\n      var el;\n\n      try {\n        el = document.querySelector(selector);\n      } catch (e) {// TODO\n      }\n\n      if (!isUndefined(selector) && !el) {\n        return console.error(\"No element was found for the selector supplied to advanceOn: \" + selector);\n      } else if (el) {\n        el.addEventListener(event, handler);\n        step.on('destroy', function () {\n          return el.removeEventListener(event, handler);\n        });\n      } else {\n        document.body.addEventListener(event, handler, true);\n        step.on('destroy', function () {\n          return document.body.removeEventListener(event, handler, true);\n        });\n      }\n    } else {\n      return console.error('advanceOn was defined, but no event name was passed.');\n    }\n  }\n\n  function getBoundingClientRect(element) {\n    var rect = element.getBoundingClientRect();\n    return {\n      width: rect.width,\n      height: rect.height,\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left,\n      x: rect.left,\n      y: rect.top\n    };\n  }\n  /*:: import type { Window } from '../types'; */\n\n  /*:: declare function getWindow(node: Node | Window): Window; */\n\n\n  function getWindow(node) {\n    if (node.toString() !== '[object Window]') {\n      var ownerDocument = node.ownerDocument;\n      return ownerDocument ? ownerDocument.defaultView : window;\n    }\n\n    return node;\n  }\n\n  function getWindowScroll(node) {\n    var win = getWindow(node);\n    var scrollLeft = win.pageXOffset;\n    var scrollTop = win.pageYOffset;\n    return {\n      scrollLeft: scrollLeft,\n      scrollTop: scrollTop\n    };\n  }\n  /*:: declare function isElement(node: mixed): boolean %checks(node instanceof\n    Element); */\n\n\n  function isElement$1(node) {\n    var OwnElement = getWindow(node).Element;\n    return node instanceof OwnElement || node instanceof Element;\n  }\n  /*:: declare function isHTMLElement(node: mixed): boolean %checks(node instanceof\n    HTMLElement); */\n\n\n  function isHTMLElement(node) {\n    var OwnElement = getWindow(node).HTMLElement;\n    return node instanceof OwnElement || node instanceof HTMLElement;\n  }\n\n  function getHTMLElementScroll(element) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n\n  function getNodeScroll(node) {\n    if (node === getWindow(node) || !isHTMLElement(node)) {\n      return getWindowScroll(node);\n    } else {\n      return getHTMLElementScroll(node);\n    }\n  }\n\n  function getNodeName(element) {\n    return element ? (element.nodeName || '').toLowerCase() : null;\n  }\n\n  function getDocumentElement(element) {\n    // $FlowFixMe: assume body is always available\n    return (isElement$1(element) ? element.ownerDocument : element.document).documentElement;\n  }\n\n  function getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    // Popper 1 is broken in this case and never had a bug report so let's assume\n    // it's not an issue. I don't think anyone ever specifies width on <html>\n    // anyway.\n    // Browsers where the left scrollbar doesn't cause an issue report `0` for\n    // this (e.g. Edge 2019, IE11, Safari)\n    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n  } // Composite means it takes into account transforms as well as layout.\n\n\n  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n    if (isFixed === void 0) {\n      isFixed = false;\n    }\n\n    var documentElement;\n    var rect = getBoundingClientRect(elementOrVirtualElement);\n    var scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    var offsets = {\n      x: 0,\n      y: 0\n    };\n\n    if (!isFixed) {\n      if (getNodeName(offsetParent) !== 'body') {\n        scroll = getNodeScroll(offsetParent);\n      }\n\n      if (isHTMLElement(offsetParent)) {\n        offsets = getBoundingClientRect(offsetParent);\n        offsets.x += offsetParent.clientLeft;\n        offsets.y += offsetParent.clientTop;\n      } else if (documentElement = getDocumentElement(offsetParent)) {\n        offsets.x = getWindowScrollBarX(documentElement);\n      }\n    }\n\n    return {\n      x: rect.left + scroll.scrollLeft - offsets.x,\n      y: rect.top + scroll.scrollTop - offsets.y,\n      width: rect.width,\n      height: rect.height\n    };\n  } // Returns the layout rect of an element relative to its offsetParent. Layout\n  // means it doesn't take into account transforms.\n\n\n  function getLayoutRect(element) {\n    return {\n      x: element.offsetLeft,\n      y: element.offsetTop,\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n\n  function getParentNode(element) {\n    if (getNodeName(element) === 'html') {\n      return element;\n    }\n\n    return (// $FlowFixMe: this is a quicker (but less type safe) way to save quite some bytes from the bundle\n      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n      element.parentNode || // DOM Element detected\n      // $FlowFixMe: need a better way to handle this...\n      element.host || // ShadowRoot detected\n      // $FlowFixMe: HTMLElement is a Node\n      getDocumentElement(element) // fallback\n\n    );\n  }\n\n  function getComputedStyle(element) {\n    return getWindow(element).getComputedStyle(element);\n  }\n\n  function getScrollParent(node) {\n    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n      // $FlowFixMe: assume body is always available\n      return node.ownerDocument.body;\n    }\n\n    if (isHTMLElement(node)) {\n      // Firefox wants us to check `-x` and `-y` variations as well\n      var _getComputedStyle = getComputedStyle(node),\n          overflow = _getComputedStyle.overflow,\n          overflowX = _getComputedStyle.overflowX,\n          overflowY = _getComputedStyle.overflowY;\n\n      if (/auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX)) {\n        return node;\n      }\n    }\n\n    return getScrollParent(getParentNode(node));\n  }\n\n  function listScrollParents(element, list) {\n    if (list === void 0) {\n      list = [];\n    }\n\n    var scrollParent = getScrollParent(element);\n    var isBody = getNodeName(scrollParent) === 'body';\n    var win = getWindow(scrollParent);\n    var target = isBody ? [win].concat(win.visualViewport || []) : scrollParent;\n    var updatedList = list.concat(target);\n    return isBody ? updatedList : // $FlowFixMe: isBody tells us target will be an HTMLElement here\n    updatedList.concat(listScrollParents(getParentNode(target)));\n  }\n\n  function isTableElement(element) {\n    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n  }\n\n  function getTrueOffsetParent(element) {\n    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n    getComputedStyle(element).position === 'fixed') {\n      return null;\n    }\n\n    return element.offsetParent;\n  }\n\n  function getOffsetParent(element) {\n    var window = getWindow(element);\n    var offsetParent = getTrueOffsetParent(element); // Find the nearest non-table offsetParent\n\n    while (offsetParent && isTableElement(offsetParent)) {\n      offsetParent = getTrueOffsetParent(offsetParent);\n    }\n\n    if (offsetParent && getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static') {\n      return window;\n    }\n\n    return offsetParent || window;\n  }\n\n  var top = 'top';\n  var bottom = 'bottom';\n  var right = 'right';\n  var left = 'left';\n  var auto = 'auto';\n  var basePlacements = [top, bottom, right, left];\n  var start = 'start';\n  var end = 'end';\n  var clippingParents = 'clippingParents';\n  var viewport = 'viewport';\n  var popper = 'popper';\n  var reference = 'reference';\n  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n    return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n  }, []);\n  var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n    return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n  }, []); // modifiers that need to read the DOM\n\n  var beforeRead = 'beforeRead';\n  var read = 'read';\n  var afterRead = 'afterRead'; // pure-logic modifiers\n\n  var beforeMain = 'beforeMain';\n  var main = 'main';\n  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\n  var beforeWrite = 'beforeWrite';\n  var write = 'write';\n  var afterWrite = 'afterWrite';\n  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n\n  function order(modifiers) {\n    var map = new Map();\n    var visited = new Set();\n    var result = [];\n    modifiers.forEach(function (modifier) {\n      map.set(modifier.name, modifier);\n    }); // On visiting object, check for its dependencies and visit them recursively\n\n    function sort(modifier) {\n      visited.add(modifier.name);\n      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n      requires.forEach(function (dep) {\n        if (!visited.has(dep)) {\n          var depModifier = map.get(dep);\n\n          if (depModifier) {\n            sort(depModifier);\n          }\n        }\n      });\n      result.push(modifier);\n    }\n\n    modifiers.forEach(function (modifier) {\n      if (!visited.has(modifier.name)) {\n        // check for visited object\n        sort(modifier);\n      }\n    });\n    return result;\n  }\n\n  function orderModifiers(modifiers) {\n    // order based on dependencies\n    var orderedModifiers = order(modifiers); // order based on phase\n\n    return modifierPhases.reduce(function (acc, phase) {\n      return acc.concat(orderedModifiers.filter(function (modifier) {\n        return modifier.phase === phase;\n      }));\n    }, []);\n  }\n\n  function debounce(fn) {\n    var pending;\n    return function () {\n      if (!pending) {\n        pending = new Promise(function (resolve) {\n          Promise.resolve().then(function () {\n            pending = undefined;\n            resolve(fn());\n          });\n        });\n      }\n\n      return pending;\n    };\n  }\n\n  function getBasePlacement(placement) {\n    return placement.split('-')[0];\n  }\n\n  function mergeByName(modifiers) {\n    var merged = modifiers.reduce(function (merged, current) {\n      var existing = merged[current.name];\n      merged[current.name] = existing ? Object.assign({}, existing, {}, current, {\n        options: Object.assign({}, existing.options, {}, current.options),\n        data: Object.assign({}, existing.data, {}, current.data)\n      }) : current;\n      return merged;\n    }, {}); // IE11 does not support Object.values\n\n    return Object.keys(merged).map(function (key) {\n      return merged[key];\n    });\n  }\n\n  var DEFAULT_OPTIONS = {\n    placement: 'bottom',\n    modifiers: [],\n    strategy: 'absolute'\n  };\n\n  function areValidElements() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return !args.some(function (element) {\n      return !(element && typeof element.getBoundingClientRect === 'function');\n    });\n  }\n\n  function popperGenerator(generatorOptions) {\n    if (generatorOptions === void 0) {\n      generatorOptions = {};\n    }\n\n    var _generatorOptions = generatorOptions,\n        _generatorOptions$def = _generatorOptions.defaultModifiers,\n        defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n        _generatorOptions$def2 = _generatorOptions.defaultOptions,\n        defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n    return function createPopper(reference, popper, options) {\n      if (options === void 0) {\n        options = defaultOptions;\n      }\n\n      var state = {\n        placement: 'bottom',\n        orderedModifiers: [],\n        options: Object.assign({}, DEFAULT_OPTIONS, {}, defaultOptions),\n        modifiersData: {},\n        elements: {\n          reference: reference,\n          popper: popper\n        },\n        attributes: {},\n        styles: {}\n      };\n      var effectCleanupFns = [];\n      var isDestroyed = false;\n      var instance = {\n        state: state,\n        setOptions: function setOptions(options) {\n          cleanupModifierEffects();\n          state.options = Object.assign({}, defaultOptions, {}, state.options, {}, options);\n          state.scrollParents = {\n            reference: isElement$1(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n            popper: listScrollParents(popper)\n          }; // Orders the modifiers based on their dependencies and `phase`\n          // properties\n\n          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n          state.orderedModifiers = orderedModifiers.filter(function (m) {\n            return m.enabled;\n          }); // Validate the provided modifiers so that the consumer will get warned\n\n          runModifierEffects();\n          return instance.update();\n        },\n        // Sync update – it will always be executed, even if not necessary. This\n        // is useful for low frequency updates where sync behavior simplifies the\n        // logic.\n        // For high frequency updates (e.g. `resize` and `scroll` events), always\n        // prefer the async Popper#update method\n        forceUpdate: function forceUpdate() {\n          if (isDestroyed) {\n            return;\n          }\n\n          var _state$elements = state.elements,\n              reference = _state$elements.reference,\n              popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n          // anymore\n\n          if (!areValidElements(reference, popper)) {\n            return;\n          } // Store the reference and popper rects to be read by modifiers\n\n\n          state.rects = {\n            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n            popper: getLayoutRect(popper)\n          }; // Modifiers have the ability to reset the current update cycle. The\n          // most common use case for this is the `flip` modifier changing the\n          // placement, which then needs to re-run all the modifiers, because the\n          // logic was previously ran for the previous placement and is therefore\n          // stale/incorrect\n\n          state.reset = false;\n          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n          // is filled with the initial data specified by the modifier. This means\n          // it doesn't persist and is fresh on each update.\n          // To ensure persistent data, use `${name}#persistent`\n\n          state.orderedModifiers.forEach(function (modifier) {\n            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n          });\n\n          for (var index = 0; index < state.orderedModifiers.length; index++) {\n            if (state.reset === true) {\n              state.reset = false;\n              index = -1;\n              continue;\n            }\n\n            var _state$orderedModifie = state.orderedModifiers[index],\n                fn = _state$orderedModifie.fn,\n                _state$orderedModifie2 = _state$orderedModifie.options,\n                _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n                name = _state$orderedModifie.name;\n\n            if (typeof fn === 'function') {\n              state = fn({\n                state: state,\n                options: _options,\n                name: name,\n                instance: instance\n              }) || state;\n            }\n          }\n        },\n        // Async and optimistically optimized update – it will not be executed if\n        // not necessary (debounced to run at most once-per-tick)\n        update: debounce(function () {\n          return new Promise(function (resolve) {\n            instance.forceUpdate();\n            resolve(state);\n          });\n        }),\n        destroy: function destroy() {\n          cleanupModifierEffects();\n          isDestroyed = true;\n        }\n      };\n\n      if (!areValidElements(reference, popper)) {\n        return instance;\n      }\n\n      instance.setOptions(options).then(function (state) {\n        if (!isDestroyed && options.onFirstUpdate) {\n          options.onFirstUpdate(state);\n        }\n      }); // Modifiers have the ability to execute arbitrary code before the first\n      // update cycle runs. They will be executed in the same order as the update\n      // cycle. This is useful when a modifier adds some persistent data that\n      // other modifiers need to use, but the modifier is run after the dependent\n      // one.\n\n      function runModifierEffects() {\n        state.orderedModifiers.forEach(function (_ref3) {\n          var name = _ref3.name,\n              _ref3$options = _ref3.options,\n              options = _ref3$options === void 0 ? {} : _ref3$options,\n              effect = _ref3.effect;\n\n          if (typeof effect === 'function') {\n            var cleanupFn = effect({\n              state: state,\n              name: name,\n              instance: instance,\n              options: options\n            });\n\n            var noopFn = function noopFn() {};\n\n            effectCleanupFns.push(cleanupFn || noopFn);\n          }\n        });\n      }\n\n      function cleanupModifierEffects() {\n        effectCleanupFns.forEach(function (fn) {\n          return fn();\n        });\n        effectCleanupFns = [];\n      }\n\n      return instance;\n    };\n  }\n\n  var passive = {\n    passive: true\n  };\n\n  function effect(_ref) {\n    var state = _ref.state,\n        instance = _ref.instance,\n        options = _ref.options;\n    var _options$scroll = options.scroll,\n        scroll = _options$scroll === void 0 ? true : _options$scroll,\n        _options$resize = options.resize,\n        resize = _options$resize === void 0 ? true : _options$resize;\n    var window = getWindow(state.elements.popper);\n    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.addEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.addEventListener('resize', instance.update, passive);\n    }\n\n    return function () {\n      if (scroll) {\n        scrollParents.forEach(function (scrollParent) {\n          scrollParent.removeEventListener('scroll', instance.update, passive);\n        });\n      }\n\n      if (resize) {\n        window.removeEventListener('resize', instance.update, passive);\n      }\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var eventListeners = {\n    name: 'eventListeners',\n    enabled: true,\n    phase: 'write',\n    fn: function fn() {},\n    effect: effect,\n    data: {}\n  };\n\n  function getVariation(placement) {\n    return placement.split('-')[1];\n  }\n\n  function getMainAxisFromPlacement(placement) {\n    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n  }\n\n  function computeOffsets(_ref) {\n    var reference = _ref.reference,\n        element = _ref.element,\n        placement = _ref.placement;\n    var basePlacement = placement ? getBasePlacement(placement) : null;\n    var variation = placement ? getVariation(placement) : null;\n    var commonX = reference.x + reference.width / 2 - element.width / 2;\n    var commonY = reference.y + reference.height / 2 - element.height / 2;\n    var offsets;\n\n    switch (basePlacement) {\n      case top:\n        offsets = {\n          x: commonX,\n          y: reference.y - element.height\n        };\n        break;\n\n      case bottom:\n        offsets = {\n          x: commonX,\n          y: reference.y + reference.height\n        };\n        break;\n\n      case right:\n        offsets = {\n          x: reference.x + reference.width,\n          y: commonY\n        };\n        break;\n\n      case left:\n        offsets = {\n          x: reference.x - element.width,\n          y: commonY\n        };\n        break;\n\n      default:\n        offsets = {\n          x: reference.x,\n          y: reference.y\n        };\n    }\n\n    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n\n    if (mainAxis != null) {\n      var len = mainAxis === 'y' ? 'height' : 'width';\n\n      switch (variation) {\n        case start:\n          offsets[mainAxis] = Math.floor(offsets[mainAxis]) - Math.floor(reference[len] / 2 - element[len] / 2);\n          break;\n\n        case end:\n          offsets[mainAxis] = Math.floor(offsets[mainAxis]) + Math.ceil(reference[len] / 2 - element[len] / 2);\n          break;\n      }\n    }\n\n    return offsets;\n  }\n\n  function popperOffsets(_ref) {\n    var state = _ref.state,\n        name = _ref.name; // Offsets are the actual position the popper needs to have to be\n    // properly positioned near its reference element\n    // This is the most basic placement, and will be adjusted by\n    // the modifiers in the next step\n\n    state.modifiersData[name] = computeOffsets({\n      reference: state.rects.reference,\n      element: state.rects.popper,\n      strategy: 'absolute',\n      placement: state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var popperOffsets$1 = {\n    name: 'popperOffsets',\n    enabled: true,\n    phase: 'read',\n    fn: popperOffsets,\n    data: {}\n  };\n  var unsetSides = {\n    top: 'auto',\n    right: 'auto',\n    bottom: 'auto',\n    left: 'auto'\n  }; // Round the offsets to the nearest suitable subpixel based on the DPR.\n  // Zooming can change the DPR, but it seems to report a value that will\n  // cleanly divide the values into the appropriate subpixels.\n\n  function roundOffsets(_ref) {\n    var x = _ref.x,\n        y = _ref.y;\n    var win = window;\n    var dpr = win.devicePixelRatio || 1;\n    return {\n      x: Math.round(x * dpr) / dpr || 0,\n      y: Math.round(y * dpr) / dpr || 0\n    };\n  }\n\n  function mapToStyles(_ref2) {\n    var _Object$assign2;\n\n    var popper = _ref2.popper,\n        popperRect = _ref2.popperRect,\n        placement = _ref2.placement,\n        offsets = _ref2.offsets,\n        position = _ref2.position,\n        gpuAcceleration = _ref2.gpuAcceleration,\n        adaptive = _ref2.adaptive;\n\n    var _roundOffsets = roundOffsets(offsets),\n        x = _roundOffsets.x,\n        y = _roundOffsets.y;\n\n    var hasX = offsets.hasOwnProperty('x');\n    var hasY = offsets.hasOwnProperty('y');\n    var sideX = left;\n    var sideY = top;\n    var win = window;\n\n    if (adaptive) {\n      var offsetParent = getOffsetParent(popper);\n\n      if (offsetParent === getWindow(popper)) {\n        offsetParent = getDocumentElement(popper);\n      } // $FlowFixMe: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n      /*:: offsetParent = (offsetParent: Element); */\n\n\n      if (placement === top) {\n        sideY = bottom;\n        y -= offsetParent.clientHeight - popperRect.height;\n        y *= gpuAcceleration ? 1 : -1;\n      }\n\n      if (placement === left) {\n        sideX = right;\n        x -= offsetParent.clientWidth - popperRect.width;\n        x *= gpuAcceleration ? 1 : -1;\n      }\n    }\n\n    var commonStyles = Object.assign({\n      position: position\n    }, adaptive && unsetSides);\n\n    if (gpuAcceleration) {\n      var _Object$assign;\n\n      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n    }\n\n    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n  }\n\n  function computeStyles(_ref3) {\n    var state = _ref3.state,\n        options = _ref3.options;\n    var _options$gpuAccelerat = options.gpuAcceleration,\n        gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n        _options$adaptive = options.adaptive,\n        adaptive = _options$adaptive === void 0 ? true : _options$adaptive;\n    var commonStyles = {\n      placement: getBasePlacement(state.placement),\n      popper: state.elements.popper,\n      popperRect: state.rects.popper,\n      gpuAcceleration: gpuAcceleration\n    };\n\n    if (state.modifiersData.popperOffsets != null) {\n      state.styles.popper = Object.assign({}, state.styles.popper, {}, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.popperOffsets,\n        position: state.options.strategy,\n        adaptive: adaptive\n      })));\n    }\n\n    if (state.modifiersData.arrow != null) {\n      state.styles.arrow = Object.assign({}, state.styles.arrow, {}, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.arrow,\n        position: 'absolute',\n        adaptive: false\n      })));\n    }\n\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-placement': state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var computeStyles$1 = {\n    name: 'computeStyles',\n    enabled: true,\n    phase: 'beforeWrite',\n    fn: computeStyles,\n    data: {}\n  }; // and applies them to the HTMLElements such as popper and arrow\n\n  function applyStyles(_ref) {\n    var state = _ref.state;\n    Object.keys(state.elements).forEach(function (name) {\n      var style = state.styles[name] || {};\n      var attributes = state.attributes[name] || {};\n      var element = state.elements[name]; // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      } // Flow doesn't support to extend this property, but it's the most\n      // effective way to apply styles to an HTMLElement\n      // $FlowFixMe\n\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (name) {\n        var value = attributes[name];\n\n        if (value === false) {\n          element.removeAttribute(name);\n        } else {\n          element.setAttribute(name, value === true ? '' : value);\n        }\n      });\n    });\n  }\n\n  function effect$1(_ref2) {\n    var state = _ref2.state;\n    var initialStyles = {\n      popper: {\n        position: state.options.strategy,\n        left: '0',\n        top: '0',\n        margin: '0'\n      },\n      arrow: {\n        position: 'absolute'\n      },\n      reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n\n    if (state.elements.arrow) {\n      Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    }\n\n    return function () {\n      Object.keys(state.elements).forEach(function (name) {\n        var element = state.elements[name];\n        var attributes = state.attributes[name] || {};\n        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n        var style = styleProperties.reduce(function (style, property) {\n          style[property] = '';\n          return style;\n        }, {}); // arrow is optional + virtual elements\n\n        if (!isHTMLElement(element) || !getNodeName(element)) {\n          return;\n        } // Flow doesn't support to extend this property, but it's the most\n        // effective way to apply styles to an HTMLElement\n        // $FlowFixMe\n\n\n        Object.assign(element.style, style);\n        Object.keys(attributes).forEach(function (attribute) {\n          element.removeAttribute(attribute);\n        });\n      });\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var applyStyles$1 = {\n    name: 'applyStyles',\n    enabled: true,\n    phase: 'write',\n    fn: applyStyles,\n    effect: effect$1,\n    requires: ['computeStyles']\n  };\n\n  function distanceAndSkiddingToXY(placement, rects, offset) {\n    var basePlacement = getBasePlacement(placement);\n    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n      placement: placement\n    })) : offset,\n        skidding = _ref[0],\n        distance = _ref[1];\n\n    skidding = skidding || 0;\n    distance = (distance || 0) * invertDistance;\n    return [left, right].indexOf(basePlacement) >= 0 ? {\n      x: distance,\n      y: skidding\n    } : {\n      x: skidding,\n      y: distance\n    };\n  }\n\n  function offset(_ref2) {\n    var state = _ref2.state,\n        options = _ref2.options,\n        name = _ref2.name;\n    var _options$offset = options.offset,\n        offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n    var data = placements.reduce(function (acc, placement) {\n      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n      return acc;\n    }, {});\n    var _data$state$placement = data[state.placement],\n        x = _data$state$placement.x,\n        y = _data$state$placement.y;\n\n    if (state.modifiersData.popperOffsets != null) {\n      state.modifiersData.popperOffsets.x += x;\n      state.modifiersData.popperOffsets.y += y;\n    }\n\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var offset$1 = {\n    name: 'offset',\n    enabled: true,\n    phase: 'main',\n    requires: ['popperOffsets'],\n    fn: offset\n  };\n  var hash = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n\n  function getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, function (matched) {\n      return hash[matched];\n    });\n  }\n\n  var hash$1 = {\n    start: 'end',\n    end: 'start'\n  };\n\n  function getOppositeVariationPlacement(placement) {\n    return placement.replace(/start|end/g, function (matched) {\n      return hash$1[matched];\n    });\n  }\n\n  function getViewportRect(element) {\n    var win = getWindow(element);\n    var visualViewport = win.visualViewport;\n    var width = win.innerWidth;\n    var height = win.innerHeight; // We don't know which browsers have buggy or odd implementations of this, so\n    // for now we're only applying it to iOS to fix the keyboard issue.\n    // Investigation required\n\n    if (visualViewport && /iPhone|iPod|iPad/.test(navigator.platform)) {\n      width = visualViewport.width;\n      height = visualViewport.height;\n    }\n\n    return {\n      width: width,\n      height: height,\n      x: 0,\n      y: 0\n    };\n  }\n\n  function getDocumentRect(element) {\n    var win = getWindow(element);\n    var winScroll = getWindowScroll(element);\n    var documentRect = getCompositeRect(getDocumentElement(element), win);\n    documentRect.height = Math.max(documentRect.height, win.innerHeight);\n    documentRect.width = Math.max(documentRect.width, win.innerWidth);\n    documentRect.x = -winScroll.scrollLeft;\n    documentRect.y = -winScroll.scrollTop;\n    return documentRect;\n  }\n\n  function toNumber(cssValue) {\n    return parseFloat(cssValue) || 0;\n  }\n\n  function getBorders(element) {\n    var computedStyle = isHTMLElement(element) ? getComputedStyle(element) : {};\n    return {\n      top: toNumber(computedStyle.borderTopWidth),\n      right: toNumber(computedStyle.borderRightWidth),\n      bottom: toNumber(computedStyle.borderBottomWidth),\n      left: toNumber(computedStyle.borderLeftWidth)\n    };\n  }\n\n  function getDecorations(element) {\n    var win = getWindow(element);\n    var borders = getBorders(element);\n    var isHTML = getNodeName(element) === 'html';\n    var winScrollBarX = getWindowScrollBarX(element);\n    var x = element.clientWidth + borders.right;\n    var y = element.clientHeight + borders.bottom; // HACK:\n    // document.documentElement.clientHeight on iOS reports the height of the\n    // viewport including the bottom bar, even if the bottom bar isn't visible.\n    // If the difference between window innerHeight and html clientHeight is more\n    // than 50, we assume it's a mobile bottom bar and ignore scrollbars.\n    // * A 50px thick scrollbar is likely non-existent (macOS is 15px and Windows\n    //   is about 17px)\n    // * The mobile bar is 114px tall\n\n    if (isHTML && win.innerHeight - element.clientHeight > 50) {\n      y = win.innerHeight - borders.bottom;\n    }\n\n    return {\n      top: isHTML ? 0 : element.clientTop,\n      right: // RTL scrollbar (scrolling containers only)\n      element.clientLeft > borders.left ? borders.right : // LTR scrollbar\n      isHTML ? win.innerWidth - x - winScrollBarX : element.offsetWidth - x,\n      bottom: isHTML ? win.innerHeight - y : element.offsetHeight - y,\n      left: isHTML ? winScrollBarX : element.clientLeft\n    };\n  }\n\n  function contains(parent, child) {\n    // $FlowFixMe: hasOwnProperty doesn't seem to work in tests\n    var isShadow = Boolean(child.getRootNode && child.getRootNode().host); // First, attempt with faster native method\n\n    if (parent.contains(child)) {\n      return true;\n    } // then fallback to custom implementation with Shadow DOM support\n    else if (isShadow) {\n        var next = child;\n\n        do {\n          if (next && parent.isSameNode(next)) {\n            return true;\n          } // $FlowFixMe: need a better way to handle this...\n\n\n          next = next.parentNode || next.host;\n        } while (next);\n      } // Give up, the result is false\n\n\n    return false;\n  }\n\n  function rectToClientRect(rect) {\n    return Object.assign({}, rect, {\n      left: rect.x,\n      top: rect.y,\n      right: rect.x + rect.width,\n      bottom: rect.y + rect.height\n    });\n  }\n\n  function getClientRectFromMixedType(element, clippingParent) {\n    return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n  } // A \"clipping parent\" is an overflowable container with the characteristic of\n  // clipping (or hiding) overflowing elements with a position different from\n  // `initial`\n\n\n  function getClippingParents(element) {\n    var clippingParents = listScrollParents(element);\n    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n    if (!isElement$1(clipperElement)) {\n      return [];\n    } // $FlowFixMe: https://github.com/facebook/flow/issues/1414\n\n\n    return clippingParents.filter(function (clippingParent) {\n      return isElement$1(clippingParent) && contains(clippingParent, clipperElement);\n    });\n  } // Gets the maximum area that the element is visible in due to any number of\n  // clipping parents\n\n\n  function getClippingRect(element, boundary, rootBoundary) {\n    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n    var firstClippingParent = clippingParents[0];\n    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n      var rect = getClientRectFromMixedType(element, clippingParent);\n      var decorations = getDecorations(isHTMLElement(clippingParent) ? clippingParent : getDocumentElement(element));\n      accRect.top = Math.max(rect.top + decorations.top, accRect.top);\n      accRect.right = Math.min(rect.right - decorations.right, accRect.right);\n      accRect.bottom = Math.min(rect.bottom - decorations.bottom, accRect.bottom);\n      accRect.left = Math.max(rect.left + decorations.left, accRect.left);\n      return accRect;\n    }, getClientRectFromMixedType(element, firstClippingParent));\n    clippingRect.width = clippingRect.right - clippingRect.left;\n    clippingRect.height = clippingRect.bottom - clippingRect.top;\n    clippingRect.x = clippingRect.left;\n    clippingRect.y = clippingRect.top;\n    return clippingRect;\n  }\n\n  function getFreshSideObject() {\n    return {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n  }\n\n  function mergePaddingObject(paddingObject) {\n    return Object.assign({}, getFreshSideObject(), {}, paddingObject);\n  }\n\n  function expandToHashMap(value, keys) {\n    return keys.reduce(function (hashMap, key) {\n      hashMap[key] = value;\n      return hashMap;\n    }, {});\n  }\n\n  function detectOverflow(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _options = options,\n        _options$placement = _options.placement,\n        placement = _options$placement === void 0 ? state.placement : _options$placement,\n        _options$boundary = _options.boundary,\n        boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n        _options$rootBoundary = _options.rootBoundary,\n        rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n        _options$elementConte = _options.elementContext,\n        elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n        _options$altBoundary = _options.altBoundary,\n        altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n        _options$padding = _options.padding,\n        padding = _options$padding === void 0 ? 0 : _options$padding;\n    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n    var altContext = elementContext === popper ? reference : popper;\n    var referenceElement = state.elements.reference;\n    var popperRect = state.rects.popper;\n    var element = state.elements[altBoundary ? altContext : elementContext];\n    var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n    var referenceClientRect = getBoundingClientRect(referenceElement);\n    var popperOffsets = computeOffsets({\n      reference: referenceClientRect,\n      element: popperRect,\n      strategy: 'absolute',\n      placement: placement\n    });\n    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, {}, popperOffsets));\n    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n    // 0 or negative = within the clipping rect\n\n    var overflowOffsets = {\n      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n      right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n    };\n    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n    if (elementContext === popper && offsetData) {\n      var offset = offsetData[placement];\n      Object.keys(overflowOffsets).forEach(function (key) {\n        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n        var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n        overflowOffsets[key] += offset[axis] * multiply;\n      });\n    }\n\n    return overflowOffsets;\n  }\n  /*:: type OverflowsMap = { [ComputedPlacement]: number }; */\n\n  /*;; type OverflowsMap = { [key in ComputedPlacement]: number }; */\n\n\n  function computeAutoPlacement(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _options = options,\n        placement = _options.placement,\n        boundary = _options.boundary,\n        rootBoundary = _options.rootBoundary,\n        padding = _options.padding,\n        flipVariations = _options.flipVariations,\n        _options$allowedAutoP = _options.allowedAutoPlacements,\n        allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n    var variation = getVariation(placement);\n    var placements$1 = (variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n      return getVariation(placement) === variation;\n    }) : basePlacements).filter(function (placement) {\n      return allowedAutoPlacements.indexOf(placement) >= 0;\n    }); // $FlowFixMe: Flow seems to have problems with two array unions...\n\n    var overflows = placements$1.reduce(function (acc, placement) {\n      acc[placement] = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding\n      })[getBasePlacement(placement)];\n      return acc;\n    }, {});\n    return Object.keys(overflows).sort(function (a, b) {\n      return overflows[a] - overflows[b];\n    });\n  }\n\n  function getExpandedFallbackPlacements(placement) {\n    if (getBasePlacement(placement) === auto) {\n      return [];\n    }\n\n    var oppositePlacement = getOppositePlacement(placement);\n    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n  }\n\n  function flip(_ref) {\n    var state = _ref.state,\n        options = _ref.options,\n        name = _ref.name;\n\n    if (state.modifiersData[name]._skip) {\n      return;\n    }\n\n    var specifiedFallbackPlacements = options.fallbackPlacements,\n        padding = options.padding,\n        boundary = options.boundary,\n        rootBoundary = options.rootBoundary,\n        altBoundary = options.altBoundary,\n        _options$flipVariatio = options.flipVariations,\n        flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n        allowedAutoPlacements = options.allowedAutoPlacements;\n    var preferredPlacement = state.options.placement;\n    var basePlacement = getBasePlacement(preferredPlacement);\n    var isBasePlacement = basePlacement === preferredPlacement;\n    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n      return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding,\n        flipVariations: flipVariations,\n        allowedAutoPlacements: allowedAutoPlacements\n      }) : placement);\n    }, []);\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var checksMap = new Map();\n    var makeFallbackChecks = true;\n    var firstFittingPlacement = placements[0];\n\n    for (var i = 0; i < placements.length; i++) {\n      var placement = placements[i];\n\n      var _basePlacement = getBasePlacement(placement);\n\n      var isStartVariation = getVariation(placement) === start;\n      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n      var len = isVertical ? 'width' : 'height';\n      var overflow = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        altBoundary: altBoundary,\n        padding: padding\n      });\n      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n\n      if (referenceRect[len] > popperRect[len]) {\n        mainVariationSide = getOppositePlacement(mainVariationSide);\n      }\n\n      var altVariationSide = getOppositePlacement(mainVariationSide);\n      var checks = [overflow[_basePlacement] <= 0, overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0];\n\n      if (checks.every(function (check) {\n        return check;\n      })) {\n        firstFittingPlacement = placement;\n        makeFallbackChecks = false;\n        break;\n      }\n\n      checksMap.set(placement, checks);\n    }\n\n    if (makeFallbackChecks) {\n      // `2` may be desired in some cases – research later\n      var numberOfChecks = flipVariations ? 3 : 1;\n\n      var _loop = function _loop(_i) {\n        var fittingPlacement = placements.find(function (placement) {\n          var checks = checksMap.get(placement);\n\n          if (checks) {\n            return checks.slice(0, _i).every(function (check) {\n              return check;\n            });\n          }\n        });\n\n        if (fittingPlacement) {\n          firstFittingPlacement = fittingPlacement;\n          return \"break\";\n        }\n      };\n\n      for (var _i = numberOfChecks; _i > 0; _i--) {\n        var _ret = _loop(_i);\n\n        if (_ret === \"break\") break;\n      }\n    }\n\n    if (state.placement !== firstFittingPlacement) {\n      state.modifiersData[name]._skip = true;\n      state.placement = firstFittingPlacement;\n      state.reset = true;\n    }\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var flip$1 = {\n    name: 'flip',\n    enabled: true,\n    phase: 'main',\n    fn: flip,\n    requiresIfExists: ['offset'],\n    data: {\n      _skip: false\n    }\n  };\n\n  function getAltAxis(axis) {\n    return axis === 'x' ? 'y' : 'x';\n  }\n\n  function within(min, value, max) {\n    return Math.max(min, Math.min(value, max));\n  }\n\n  function preventOverflow(_ref) {\n    var state = _ref.state,\n        options = _ref.options,\n        name = _ref.name;\n    var _options$mainAxis = options.mainAxis,\n        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n        _options$altAxis = options.altAxis,\n        checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n        boundary = options.boundary,\n        rootBoundary = options.rootBoundary,\n        altBoundary = options.altBoundary,\n        padding = options.padding,\n        _options$tether = options.tether,\n        tether = _options$tether === void 0 ? true : _options$tether,\n        _options$tetherOffset = options.tetherOffset,\n        tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n    var overflow = detectOverflow(state, {\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      altBoundary: altBoundary\n    });\n    var basePlacement = getBasePlacement(state.placement);\n    var variation = getVariation(state.placement);\n    var isBasePlacement = !variation;\n    var mainAxis = getMainAxisFromPlacement(basePlacement);\n    var altAxis = getAltAxis(mainAxis);\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : tetherOffset;\n    var data = {\n      x: 0,\n      y: 0\n    };\n\n    if (!popperOffsets) {\n      return;\n    }\n\n    if (checkMainAxis) {\n      var mainSide = mainAxis === 'y' ? top : left;\n      var altSide = mainAxis === 'y' ? bottom : right;\n      var len = mainAxis === 'y' ? 'height' : 'width';\n      var offset = popperOffsets[mainAxis];\n      var min = popperOffsets[mainAxis] + overflow[mainSide];\n      var max = popperOffsets[mainAxis] - overflow[altSide];\n      var additive = tether ? -popperRect[len] / 2 : 0;\n      var minLen = variation === start ? referenceRect[len] : popperRect[len];\n      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n      // outside the reference bounds\n\n      var arrowElement = state.elements.arrow;\n      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n        width: 0,\n        height: 0\n      };\n      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n      var arrowPaddingMin = arrowPaddingObject[mainSide];\n      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n      // to include its full size in the calculation. If the reference is small\n      // and near the edge of a boundary, the popper can overflow even if the\n      // reference is not overflowing as well (e.g. virtual elements with no\n      // width or height)\n\n      var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n      var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n      var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n      var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n      var preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);\n      popperOffsets[mainAxis] = preventedOffset;\n      data[mainAxis] = preventedOffset - offset;\n    }\n\n    if (checkAltAxis) {\n      var _mainSide = mainAxis === 'x' ? top : left;\n\n      var _altSide = mainAxis === 'x' ? bottom : right;\n\n      var _offset = popperOffsets[altAxis];\n\n      var _min = _offset + overflow[_mainSide];\n\n      var _max = _offset - overflow[_altSide];\n\n      var _preventedOffset = within(_min, _offset, _max);\n\n      popperOffsets[altAxis] = _preventedOffset;\n      data[altAxis] = _preventedOffset - _offset;\n    }\n\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var preventOverflow$1 = {\n    name: 'preventOverflow',\n    enabled: true,\n    phase: 'main',\n    fn: preventOverflow,\n    requiresIfExists: ['offset']\n  };\n\n  function arrow(_ref) {\n    var _state$modifiersData$;\n\n    var state = _ref.state,\n        name = _ref.name;\n    var arrowElement = state.elements.arrow;\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var basePlacement = getBasePlacement(state.placement);\n    var axis = getMainAxisFromPlacement(basePlacement);\n    var isVertical = [left, right].indexOf(basePlacement) >= 0;\n    var len = isVertical ? 'height' : 'width';\n\n    if (!arrowElement || !popperOffsets) {\n      return;\n    }\n\n    var paddingObject = state.modifiersData[name + \"#persistent\"].padding;\n    var arrowRect = getLayoutRect(arrowElement);\n    var minProp = axis === 'y' ? top : left;\n    var maxProp = axis === 'y' ? bottom : right;\n    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n    var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n    // outside of the popper bounds\n\n    var min = paddingObject[minProp];\n    var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n    var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n    var axisProp = axis;\n    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n  }\n\n  function effect$2(_ref2) {\n    var state = _ref2.state,\n        options = _ref2.options,\n        name = _ref2.name;\n    var _options$element = options.element,\n        arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element,\n        _options$padding = options.padding,\n        padding = _options$padding === void 0 ? 0 : _options$padding;\n\n    if (arrowElement == null) {\n      return;\n    } // CSS selector\n\n\n    if (typeof arrowElement === 'string') {\n      arrowElement = state.elements.popper.querySelector(arrowElement);\n\n      if (!arrowElement) {\n        return;\n      }\n    }\n\n    if (!contains(state.elements.popper, arrowElement)) {\n      return;\n    }\n\n    state.elements.arrow = arrowElement;\n    state.modifiersData[name + \"#persistent\"] = {\n      padding: mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements))\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var arrow$1 = {\n    name: 'arrow',\n    enabled: true,\n    phase: 'main',\n    fn: arrow,\n    effect: effect$2,\n    requires: ['popperOffsets'],\n    requiresIfExists: ['preventOverflow']\n  };\n\n  function getSideOffsets(overflow, rect, preventedOffsets) {\n    if (preventedOffsets === void 0) {\n      preventedOffsets = {\n        x: 0,\n        y: 0\n      };\n    }\n\n    return {\n      top: overflow.top - rect.height - preventedOffsets.y,\n      right: overflow.right - rect.width + preventedOffsets.x,\n      bottom: overflow.bottom - rect.height + preventedOffsets.y,\n      left: overflow.left - rect.width - preventedOffsets.x\n    };\n  }\n\n  function isAnySideFullyClipped(overflow) {\n    return [top, right, bottom, left].some(function (side) {\n      return overflow[side] >= 0;\n    });\n  }\n\n  function hide(_ref) {\n    var state = _ref.state,\n        name = _ref.name;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var preventedOffsets = state.modifiersData.preventOverflow;\n    var referenceOverflow = detectOverflow(state, {\n      elementContext: 'reference'\n    });\n    var popperAltOverflow = detectOverflow(state, {\n      altBoundary: true\n    });\n    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n    state.modifiersData[name] = {\n      referenceClippingOffsets: referenceClippingOffsets,\n      popperEscapeOffsets: popperEscapeOffsets,\n      isReferenceHidden: isReferenceHidden,\n      hasPopperEscaped: hasPopperEscaped\n    };\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-reference-hidden': isReferenceHidden,\n      'data-popper-escaped': hasPopperEscaped\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var hide$1 = {\n    name: 'hide',\n    enabled: true,\n    phase: 'main',\n    requiresIfExists: ['preventOverflow'],\n    fn: hide\n  };\n  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];\n  var createPopper = /*#__PURE__*/popperGenerator({\n    defaultModifiers: defaultModifiers\n  }); // eslint-disable-next-line import/no-unused-modules\n\n  function _getCenteredStylePopperModifier() {\n    return [{\n      name: 'applyStyles',\n      fn: function fn(_ref) {\n        var state = _ref.state;\n        Object.keys(state.elements).forEach(function (name) {\n          if (name !== 'popper') {\n            return;\n          }\n\n          var style = {\n            position: 'fixed',\n            left: '50%',\n            top: '50%',\n            transform: 'translate(-50%, -50%)'\n          };\n          var attributes = state.attributes[name] || {};\n          var element = state.elements[name];\n          Object.assign(element.style, style);\n          Object.keys(attributes).forEach(function (name) {\n            var value = attributes[name];\n\n            if (value === false) {\n              element.removeAttribute(name);\n            } else {\n              element.setAttribute(name, value === true ? '' : value);\n            }\n          });\n        });\n      }\n    }, {\n      name: 'computeStyles',\n      options: {\n        adaptive: false\n      }\n    }];\n  }\n  /**\n   * Generates the array of options for a tooltip that doesn't have a\n   * target element in the DOM -- and thus is positioned in the center\n   * of the view\n   *\n   * @param {Step} step The step instance\n   * @return {Object} The final Popper options object\n   */\n\n\n  function makeCenteredPopper(step) {\n    var centeredStylePopperModifier = _getCenteredStylePopperModifier();\n\n    var popperOptions = {\n      placement: 'top',\n      strategy: 'fixed',\n      modifiers: [],\n      onFirstUpdate: function onFirstUpdate() {\n        step.el.focus();\n      }\n    };\n    popperOptions = _extends({}, popperOptions, {\n      modifiers: Array.from(new Set([].concat(popperOptions.modifiers, centeredStylePopperModifier)))\n    });\n    return popperOptions;\n  }\n  /**\n   * Ensure class prefix ends in `-`\n   * @param {string} prefix The prefix to prepend to the class names generated by nano-css\n   * @return {string} The prefix ending in `-`\n   */\n\n\n  function normalizePrefix(prefix) {\n    if (!isString(prefix) || prefix === '') {\n      return '';\n    }\n\n    return prefix.charAt(prefix.length - 1) !== '-' ? prefix + \"-\" : prefix;\n  }\n  /**\n   * Checks if options.attachTo.element is a string, and if so, tries to find the element\n   * @param {Step} step The step instance\n   * @returns {{element, on}}\n   * `element` is a qualified HTML Element\n   * `on` is a string position value\n   */\n\n\n  function parseAttachTo(step) {\n    var options = step.options.attachTo || {};\n    var returnOpts = Object.assign({}, options);\n\n    if (isString(options.element)) {\n      // Can't override the element in user opts reference because we can't\n      // guarantee that the element will exist in the future.\n      try {\n        returnOpts.element = document.querySelector(options.element);\n      } catch (e) {// TODO\n      }\n\n      if (!returnOpts.element) {\n        console.error(\"The element for this Shepherd step was not found \" + options.element);\n      }\n    }\n\n    return returnOpts;\n  }\n  /**\n   * Determines options for the tooltip and initializes\n   * `step.tooltip` as a Popper instance.\n   * @param {Step} step The step instance\n   */\n\n\n  function setupTooltip(step) {\n    if (step.tooltip) {\n      step.tooltip.destroy();\n    }\n\n    var attachToOptions = parseAttachTo(step);\n    var target = attachToOptions.element;\n    var popperOptions = getPopperOptions(attachToOptions, step);\n\n    if (step.isCentered()) {\n      target = document.body;\n      var content = step.shepherdElementComponent.getElement();\n      content.classList.add('shepherd-centered');\n    }\n\n    step.tooltip = createPopper(target, step.el, popperOptions);\n    step.target = attachToOptions.element;\n    return popperOptions;\n  }\n  /**\n   * Create a unique id for steps, tours, modals, etc\n   * @return {string}\n   */\n\n\n  function uuid() {\n    var d = Date.now();\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = (d + Math.random() * 16) % 16 | 0;\n      d = Math.floor(d / 16);\n      return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n    });\n  }\n  /**\n   * Gets the `Popper` options from a set of base `attachTo` options\n   * @param attachToOptions\n   * @param {Step} step The step instance\n   * @return {Object}\n   * @private\n   */\n\n\n  function getPopperOptions(attachToOptions, step) {\n    var popperOptions = {\n      modifiers: [{\n        name: 'preventOverflow',\n        options: {\n          altAxis: true\n        }\n      }],\n      strategy: 'absolute',\n      onFirstUpdate: function onFirstUpdate() {\n        step.el.focus();\n      }\n    };\n\n    if (step.isCentered()) {\n      popperOptions = makeCenteredPopper(step);\n    } else {\n      popperOptions.placement = attachToOptions.on;\n    }\n\n    var defaultStepOptions = step.tour && step.tour.options && step.tour.options.defaultStepOptions;\n\n    if (defaultStepOptions) {\n      popperOptions = _mergeModifiers(defaultStepOptions, popperOptions);\n    }\n\n    popperOptions = _mergeModifiers(step.options, popperOptions);\n    return popperOptions;\n  }\n\n  function _mergeModifiers(stepOptions, popperOptions) {\n    if (stepOptions.popperOptions) {\n      var mergedPopperOptions = Object.assign({}, popperOptions, stepOptions.popperOptions);\n\n      if (stepOptions.popperOptions.modifiers && stepOptions.popperOptions.modifiers.length > 0) {\n        var names = stepOptions.popperOptions.modifiers.map(function (mod) {\n          return mod.name;\n        });\n        var filteredModifiers = popperOptions.modifiers.filter(function (mod) {\n          return !names.includes(mod.name);\n        });\n        mergedPopperOptions.modifiers = Array.from(new Set([].concat(filteredModifiers, stepOptions.popperOptions.modifiers)));\n      }\n\n      return mergedPopperOptions;\n    }\n\n    return popperOptions;\n  }\n\n  function noop() {}\n\n  function assign(tar, src) {\n    // @ts-ignore\n    for (var k in src) {\n      tar[k] = src[k];\n    }\n\n    return tar;\n  }\n\n  function run(fn) {\n    return fn();\n  }\n\n  function blank_object() {\n    return Object.create(null);\n  }\n\n  function run_all(fns) {\n    fns.forEach(run);\n  }\n\n  function is_function(thing) {\n    return typeof thing === 'function';\n  }\n\n  function safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || a && _typeof(a) === 'object' || typeof a === 'function';\n  }\n\n  function append(target, node) {\n    target.appendChild(node);\n  }\n\n  function insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n  }\n\n  function detach(node) {\n    node.parentNode.removeChild(node);\n  }\n\n  function destroy_each(iterations, detaching) {\n    for (var i = 0; i < iterations.length; i += 1) {\n      if (iterations[i]) iterations[i].d(detaching);\n    }\n  }\n\n  function element(name) {\n    return document.createElement(name);\n  }\n\n  function svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n  }\n\n  function text(data) {\n    return document.createTextNode(data);\n  }\n\n  function space() {\n    return text(' ');\n  }\n\n  function empty() {\n    return text('');\n  }\n\n  function listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return function () {\n      return node.removeEventListener(event, handler, options);\n    };\n  }\n\n  function attr(node, attribute, value) {\n    if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n  }\n\n  function set_attributes(node, attributes) {\n    // @ts-ignore\n    var descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n\n    for (var key in attributes) {\n      if (attributes[key] == null) {\n        node.removeAttribute(key);\n      } else if (key === 'style') {\n        node.style.cssText = attributes[key];\n      } else if (key === '__value' || descriptors[key] && descriptors[key].set) {\n        node[key] = attributes[key];\n      } else {\n        attr(node, key, attributes[key]);\n      }\n    }\n  }\n\n  function children(element) {\n    return Array.from(element.childNodes);\n  }\n\n  function toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n  }\n\n  var current_component;\n\n  function set_current_component(component) {\n    current_component = component;\n  }\n\n  function get_current_component() {\n    if (!current_component) throw new Error(\"Function called outside component initialization\");\n    return current_component;\n  }\n\n  function onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n  }\n\n  function afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n  }\n\n  var dirty_components = [];\n  var binding_callbacks = [];\n  var render_callbacks = [];\n  var flush_callbacks = [];\n  var resolved_promise = Promise.resolve();\n  var update_scheduled = false;\n\n  function schedule_update() {\n    if (!update_scheduled) {\n      update_scheduled = true;\n      resolved_promise.then(flush);\n    }\n  }\n\n  function add_render_callback(fn) {\n    render_callbacks.push(fn);\n  }\n\n  var flushing = false;\n  var seen_callbacks = new Set();\n\n  function flush() {\n    if (flushing) return;\n    flushing = true;\n\n    do {\n      // first, call beforeUpdate functions\n      // and update components\n      for (var i = 0; i < dirty_components.length; i += 1) {\n        var component = dirty_components[i];\n        set_current_component(component);\n        update(component.$$);\n      }\n\n      dirty_components.length = 0;\n\n      while (binding_callbacks.length) {\n        binding_callbacks.pop()();\n      } // then, once components are updated, call\n      // afterUpdate functions. This may cause\n      // subsequent updates...\n\n\n      for (var _i = 0; _i < render_callbacks.length; _i += 1) {\n        var callback = render_callbacks[_i];\n\n        if (!seen_callbacks.has(callback)) {\n          // ...so guard against infinite loops\n          seen_callbacks.add(callback);\n          callback();\n        }\n      }\n\n      render_callbacks.length = 0;\n    } while (dirty_components.length);\n\n    while (flush_callbacks.length) {\n      flush_callbacks.pop()();\n    }\n\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n  }\n\n  function update($$) {\n    if ($$.fragment !== null) {\n      $$.update();\n      run_all($$.before_update);\n      var dirty = $$.dirty;\n      $$.dirty = [-1];\n      $$.fragment && $$.fragment.p($$.ctx, dirty);\n      $$.after_update.forEach(add_render_callback);\n    }\n  }\n\n  var outroing = new Set();\n  var outros;\n\n  function group_outros() {\n    outros = {\n      r: 0,\n      c: [],\n      p: outros // parent group\n\n    };\n  }\n\n  function check_outros() {\n    if (!outros.r) {\n      run_all(outros.c);\n    }\n\n    outros = outros.p;\n  }\n\n  function transition_in(block, local) {\n    if (block && block.i) {\n      outroing.delete(block);\n      block.i(local);\n    }\n  }\n\n  function transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n      if (outroing.has(block)) return;\n      outroing.add(block);\n      outros.c.push(function () {\n        outroing.delete(block);\n\n        if (callback) {\n          if (detach) block.d(1);\n          callback();\n        }\n      });\n      block.o(local);\n    }\n  }\n\n  function get_spread_update(levels, updates) {\n    var update = {};\n    var to_null_out = {};\n    var accounted_for = {\n      $$scope: 1\n    };\n    var i = levels.length;\n\n    while (i--) {\n      var o = levels[i];\n      var n = updates[i];\n\n      if (n) {\n        for (var key in o) {\n          if (!(key in n)) to_null_out[key] = 1;\n        }\n\n        for (var _key3 in n) {\n          if (!accounted_for[_key3]) {\n            update[_key3] = n[_key3];\n            accounted_for[_key3] = 1;\n          }\n        }\n\n        levels[i] = n;\n      } else {\n        for (var _key4 in o) {\n          accounted_for[_key4] = 1;\n        }\n      }\n    }\n\n    for (var _key5 in to_null_out) {\n      if (!(_key5 in update)) update[_key5] = undefined;\n    }\n\n    return update;\n  }\n\n  function create_component(block) {\n    block && block.c();\n  }\n\n  function mount_component(component, target, anchor) {\n    var _component$$$ = component.$$,\n        fragment = _component$$$.fragment,\n        on_mount = _component$$$.on_mount,\n        on_destroy = _component$$$.on_destroy,\n        after_update = _component$$$.after_update;\n    fragment && fragment.m(target, anchor); // onMount happens before the initial afterUpdate\n\n    add_render_callback(function () {\n      var new_on_destroy = on_mount.map(run).filter(is_function);\n\n      if (on_destroy) {\n        on_destroy.push.apply(on_destroy, new_on_destroy);\n      } else {\n        // Edge case - component was destroyed immediately,\n        // most likely as a result of a binding initialising\n        run_all(new_on_destroy);\n      }\n\n      component.$$.on_mount = [];\n    });\n    after_update.forEach(add_render_callback);\n  }\n\n  function destroy_component(component, detaching) {\n    var $$ = component.$$;\n\n    if ($$.fragment !== null) {\n      run_all($$.on_destroy);\n      $$.fragment && $$.fragment.d(detaching); // TODO null out other refs, including component.$$ (but need to\n      // preserve final state?)\n\n      $$.on_destroy = $$.fragment = null;\n      $$.ctx = [];\n    }\n  }\n\n  function make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n      dirty_components.push(component);\n      schedule_update();\n      component.$$.dirty.fill(0);\n    }\n\n    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n  }\n\n  function init(component, options, instance, create_fragment, not_equal, props, dirty) {\n    if (dirty === void 0) {\n      dirty = [-1];\n    }\n\n    var parent_component = current_component;\n    set_current_component(component);\n    var prop_values = options.props || {};\n    var $$ = component.$$ = {\n      fragment: null,\n      ctx: null,\n      // state\n      props: props,\n      update: noop,\n      not_equal: not_equal,\n      bound: blank_object(),\n      // lifecycle\n      on_mount: [],\n      on_destroy: [],\n      before_update: [],\n      after_update: [],\n      context: new Map(parent_component ? parent_component.$$.context : []),\n      // everything else\n      callbacks: blank_object(),\n      dirty: dirty\n    };\n    var ready = false;\n    $$.ctx = instance ? instance(component, prop_values, function (i, ret) {\n      var value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;\n\n      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n        if ($$.bound[i]) $$.bound[i](value);\n        if (ready) make_dirty(component, i);\n      }\n\n      return ret;\n    }) : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update); // `false` as a special case of no DOM component\n\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n\n    if (options.target) {\n      if (options.hydrate) {\n        var nodes = children(options.target); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        $$.fragment && $$.fragment.l(nodes);\n        nodes.forEach(detach);\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        $$.fragment && $$.fragment.c();\n      }\n\n      if (options.intro) transition_in(component.$$.fragment);\n      mount_component(component, options.target, options.anchor);\n      flush();\n    }\n\n    set_current_component(parent_component);\n  }\n\n  var SvelteComponent = /*#__PURE__*/function () {\n    function SvelteComponent() {}\n\n    var _proto3 = SvelteComponent.prototype;\n\n    _proto3.$destroy = function $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    };\n\n    _proto3.$on = function $on(type, callback) {\n      var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return function () {\n        var index = callbacks.indexOf(callback);\n        if (index !== -1) callbacks.splice(index, 1);\n      };\n    };\n\n    _proto3.$set = function $set() {// overridden by instance, if it has props\n    };\n\n    return SvelteComponent;\n  }();\n\n  function create_fragment(ctx) {\n    var button;\n    var button_aria_label_value;\n    var button_class_value;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        attr(button, \"aria-label\", button_aria_label_value =\n        /*label*/\n        ctx[4] ?\n        /*label*/\n        ctx[4] : null);\n        attr(button, \"class\", button_class_value = (\n        /*classes*/\n        ctx[1] || \"\") + \" shepherd-button \" + (\n        /*secondary*/\n        ctx[2] ? \"shepherd-button-secondary\" : \"\"));\n        button.disabled =\n        /*disabled*/\n        ctx[5];\n        attr(button, \"tabindex\", \"0\");\n      },\n      m: function m(target, anchor, remount) {\n        insert(target, button, anchor);\n        button.innerHTML =\n        /*text*/\n        ctx[3];\n        if (remount) dispose();\n        dispose = listen(button, \"click\", function () {\n          if (is_function(\n          /*action*/\n          ctx[0]))\n            /*action*/\n            ctx[0].apply(this, arguments);\n        });\n      },\n      p: function p(new_ctx, _ref) {\n        var dirty = _ref[0];\n        ctx = new_ctx;\n        if (dirty &\n        /*text*/\n        8) button.innerHTML =\n        /*text*/\n        ctx[3];\n\n        if (dirty &\n        /*label*/\n        16 && button_aria_label_value !== (button_aria_label_value =\n        /*label*/\n        ctx[4] ?\n        /*label*/\n        ctx[4] : null)) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n\n        if (dirty &\n        /*classes, secondary*/\n        6 && button_class_value !== (button_class_value = (\n        /*classes*/\n        ctx[1] || \"\") + \" shepherd-button \" + (\n        /*secondary*/\n        ctx[2] ? \"shepherd-button-secondary\" : \"\"))) {\n          attr(button, \"class\", button_class_value);\n        }\n\n        if (dirty &\n        /*disabled*/\n        32) {\n          button.disabled =\n          /*disabled*/\n          ctx[5];\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        dispose();\n      }\n    };\n  }\n\n  function instance($$self, $$props, $$invalidate) {\n    var config = $$props.config,\n        step = $$props.step;\n    var action, classes, secondary, text, label, disabled;\n\n    function getDisabled(disabled) {\n      if (isFunction(disabled)) {\n        return disabled = disabled.call(step);\n      }\n\n      return disabled;\n    }\n\n    $$self.$set = function ($$props) {\n      if (\"config\" in $$props) $$invalidate(6, config = $$props.config);\n      if (\"step\" in $$props) $$invalidate(7, step = $$props.step);\n    };\n\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty &\n      /*config, step*/\n      192) {\n        {\n          $$invalidate(0, action = config.action ? config.action.bind(step.tour) : null);\n          $$invalidate(1, classes = config.classes);\n          $$invalidate(2, secondary = config.secondary);\n          $$invalidate(3, text = config.text);\n          $$invalidate(4, label = config.label);\n          $$invalidate(5, disabled = config.disabled ? getDisabled(config.disabled) : false);\n        }\n      }\n    };\n\n    return [action, classes, secondary, text, label, disabled, config, step];\n  }\n\n  var Shepherd_button = /*#__PURE__*/function (_SvelteComponent) {\n    _inheritsLoose(Shepherd_button, _SvelteComponent);\n\n    function Shepherd_button(options) {\n      var _this;\n\n      _this = _SvelteComponent.call(this) || this;\n      init(_assertThisInitialized(_this), options, instance, create_fragment, safe_not_equal, {\n        config: 6,\n        step: 7\n      });\n      return _this;\n    }\n\n    return Shepherd_button;\n  }(SvelteComponent);\n\n  function get_each_context(ctx, list, i) {\n    var child_ctx = ctx.slice();\n    child_ctx[2] = list[i];\n    return child_ctx;\n  } // (25:4) {#if buttons}\n\n\n  function create_if_block(ctx) {\n    var each_1_anchor;\n    var current;\n    var each_value =\n    /*buttons*/\n    ctx[1];\n    var each_blocks = [];\n\n    for (var i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));\n    }\n\n    var out = function out(i) {\n      return transition_out(each_blocks[i], 1, 1, function () {\n        each_blocks[i] = null;\n      });\n    };\n\n    return {\n      c: function c() {\n        for (var _i = 0; _i < each_blocks.length; _i += 1) {\n          each_blocks[_i].c();\n        }\n\n        each_1_anchor = empty();\n      },\n      m: function m(target, anchor) {\n        for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {\n          each_blocks[_i2].m(target, anchor);\n        }\n\n        insert(target, each_1_anchor, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        if (dirty &\n        /*buttons, step*/\n        3) {\n          each_value =\n          /*buttons*/\n          ctx[1];\n\n          var _i3;\n\n          for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {\n            var child_ctx = get_each_context(ctx, each_value, _i3);\n\n            if (each_blocks[_i3]) {\n              each_blocks[_i3].p(child_ctx, dirty);\n\n              transition_in(each_blocks[_i3], 1);\n            } else {\n              each_blocks[_i3] = create_each_block(child_ctx);\n\n              each_blocks[_i3].c();\n\n              transition_in(each_blocks[_i3], 1);\n\n              each_blocks[_i3].m(each_1_anchor.parentNode, each_1_anchor);\n            }\n          }\n\n          group_outros();\n\n          for (_i3 = each_value.length; _i3 < each_blocks.length; _i3 += 1) {\n            out(_i3);\n          }\n\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n\n        for (var _i4 = 0; _i4 < each_value.length; _i4 += 1) {\n          transition_in(each_blocks[_i4]);\n        }\n\n        current = true;\n      },\n      o: function o(local) {\n        each_blocks = each_blocks.filter(Boolean);\n\n        for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {\n          transition_out(each_blocks[_i5]);\n        }\n\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_each(each_blocks, detaching);\n        if (detaching) detach(each_1_anchor);\n      }\n    };\n  } // (26:8) {#each buttons as config}\n\n\n  function create_each_block(ctx) {\n    var current;\n    var shepherdbutton = new Shepherd_button({\n      props: {\n        config:\n        /*config*/\n        ctx[2],\n        step:\n        /*step*/\n        ctx[0]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdbutton.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdbutton, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdbutton_changes = {};\n        if (dirty &\n        /*buttons*/\n        2) shepherdbutton_changes.config =\n        /*config*/\n        ctx[2];\n        if (dirty &\n        /*step*/\n        1) shepherdbutton_changes.step =\n        /*step*/\n        ctx[0];\n        shepherdbutton.$set(shepherdbutton_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdbutton.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdbutton.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdbutton, detaching);\n      }\n    };\n  }\n\n  function create_fragment$1(ctx) {\n    var footer;\n    var current;\n    var if_block =\n    /*buttons*/\n    ctx[1] && create_if_block(ctx);\n    return {\n      c: function c() {\n        footer = element(\"footer\");\n        if (if_block) if_block.c();\n        attr(footer, \"class\", \"shepherd-footer\");\n      },\n      m: function m(target, anchor) {\n        insert(target, footer, anchor);\n        if (if_block) if_block.m(footer, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var dirty = _ref[0];\n\n        if (\n        /*buttons*/\n        ctx[1]) {\n          if (if_block) {\n            if_block.p(ctx, dirty);\n\n            if (dirty &\n            /*buttons*/\n            2) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block(ctx);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(footer, null);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, function () {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(footer);\n        if (if_block) if_block.d();\n      }\n    };\n  }\n\n  function instance$1($$self, $$props, $$invalidate) {\n    var step = $$props.step;\n\n    $$self.$set = function ($$props) {\n      if (\"step\" in $$props) $$invalidate(0, step = $$props.step);\n    };\n\n    var buttons;\n\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty &\n      /*step*/\n      1) {\n        $$invalidate(1, buttons = step.options.buttons);\n      }\n    };\n\n    return [step, buttons];\n  }\n\n  var Shepherd_footer = /*#__PURE__*/function (_SvelteComponent) {\n    _inheritsLoose(Shepherd_footer, _SvelteComponent);\n\n    function Shepherd_footer(options) {\n      var _this;\n\n      _this = _SvelteComponent.call(this) || this;\n      init(_assertThisInitialized(_this), options, instance$1, create_fragment$1, safe_not_equal, {\n        step: 0\n      });\n      return _this;\n    }\n\n    return Shepherd_footer;\n  }(SvelteComponent);\n\n  function create_fragment$2(ctx) {\n    var button;\n    var span;\n    var button_aria_label_value;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        span = element(\"span\");\n        span.textContent = \"×\";\n        attr(span, \"aria-hidden\", \"true\");\n        attr(button, \"aria-label\", button_aria_label_value =\n        /*cancelIcon*/\n        ctx[0].label ?\n        /*cancelIcon*/\n        ctx[0].label : \"Close Tour\");\n        attr(button, \"class\", \"shepherd-cancel-icon\");\n        attr(button, \"type\", \"button\");\n      },\n      m: function m(target, anchor, remount) {\n        insert(target, button, anchor);\n        append(button, span);\n        if (remount) dispose();\n        dispose = listen(button, \"click\",\n        /*handleCancelClick*/\n        ctx[1]);\n      },\n      p: function p(ctx, _ref) {\n        var dirty = _ref[0];\n\n        if (dirty &\n        /*cancelIcon*/\n        1 && button_aria_label_value !== (button_aria_label_value =\n        /*cancelIcon*/\n        ctx[0].label ?\n        /*cancelIcon*/\n        ctx[0].label : \"Close Tour\")) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        dispose();\n      }\n    };\n  }\n\n  function instance$2($$self, $$props, $$invalidate) {\n    var cancelIcon = $$props.cancelIcon,\n        step = $$props.step;\n    /**\n    * Add a click listener to the cancel link that cancels the tour\n    */\n\n    var handleCancelClick = function handleCancelClick(e) {\n      e.preventDefault();\n      step.cancel();\n    };\n\n    $$self.$set = function ($$props) {\n      if (\"cancelIcon\" in $$props) $$invalidate(0, cancelIcon = $$props.cancelIcon);\n      if (\"step\" in $$props) $$invalidate(2, step = $$props.step);\n    };\n\n    return [cancelIcon, handleCancelClick, step];\n  }\n\n  var Shepherd_cancel_icon = /*#__PURE__*/function (_SvelteComponent) {\n    _inheritsLoose(Shepherd_cancel_icon, _SvelteComponent);\n\n    function Shepherd_cancel_icon(options) {\n      var _this;\n\n      _this = _SvelteComponent.call(this) || this;\n      init(_assertThisInitialized(_this), options, instance$2, create_fragment$2, safe_not_equal, {\n        cancelIcon: 0,\n        step: 2\n      });\n      return _this;\n    }\n\n    return Shepherd_cancel_icon;\n  }(SvelteComponent);\n\n  function create_fragment$3(ctx) {\n    var h3;\n    return {\n      c: function c() {\n        h3 = element(\"h3\");\n        attr(h3, \"id\",\n        /*labelId*/\n        ctx[1]);\n        attr(h3, \"class\", \"shepherd-title\");\n      },\n      m: function m(target, anchor) {\n        insert(target, h3, anchor);\n        /*h3_binding*/\n\n        ctx[3](h3);\n      },\n      p: function p(ctx, _ref) {\n        var dirty = _ref[0];\n\n        if (dirty &\n        /*labelId*/\n        2) {\n          attr(h3, \"id\",\n          /*labelId*/\n          ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(h3);\n        /*h3_binding*/\n\n        ctx[3](null);\n      }\n    };\n  }\n\n  function instance$3($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n        element = $$props.element,\n        title = $$props.title;\n    afterUpdate(function () {\n      if (isFunction(title)) {\n        $$invalidate(2, title = title());\n      }\n\n      $$invalidate(0, element.innerHTML = title, element);\n    });\n\n    function h3_binding($$value) {\n      binding_callbacks[$$value ? \"unshift\" : \"push\"](function () {\n        $$invalidate(0, element = $$value);\n      });\n    }\n\n    $$self.$set = function ($$props) {\n      if (\"labelId\" in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if (\"element\" in $$props) $$invalidate(0, element = $$props.element);\n      if (\"title\" in $$props) $$invalidate(2, title = $$props.title);\n    };\n\n    return [element, labelId, title, h3_binding];\n  }\n\n  var Shepherd_title = /*#__PURE__*/function (_SvelteComponent) {\n    _inheritsLoose(Shepherd_title, _SvelteComponent);\n\n    function Shepherd_title(options) {\n      var _this;\n\n      _this = _SvelteComponent.call(this) || this;\n      init(_assertThisInitialized(_this), options, instance$3, create_fragment$3, safe_not_equal, {\n        labelId: 1,\n        element: 0,\n        title: 2\n      });\n      return _this;\n    }\n\n    return Shepherd_title;\n  }(SvelteComponent);\n\n  function create_if_block_1(ctx) {\n    var current;\n    var shepherdtitle = new Shepherd_title({\n      props: {\n        labelId:\n        /*labelId*/\n        ctx[0],\n        title:\n        /*title*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtitle.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtitle, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtitle_changes = {};\n        if (dirty &\n        /*labelId*/\n        1) shepherdtitle_changes.labelId =\n        /*labelId*/\n        ctx[0];\n        if (dirty &\n        /*title*/\n        4) shepherdtitle_changes.title =\n        /*title*/\n        ctx[2];\n        shepherdtitle.$set(shepherdtitle_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtitle.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtitle.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtitle, detaching);\n      }\n    };\n  } // (40:4) {#if cancelIcon && cancelIcon.enabled}\n\n\n  function create_if_block$1(ctx) {\n    var current;\n    var shepherdcancelicon = new Shepherd_cancel_icon({\n      props: {\n        cancelIcon:\n        /*cancelIcon*/\n        ctx[3],\n        step:\n        /*step*/\n        ctx[1]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdcancelicon.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdcancelicon, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdcancelicon_changes = {};\n        if (dirty &\n        /*cancelIcon*/\n        8) shepherdcancelicon_changes.cancelIcon =\n        /*cancelIcon*/\n        ctx[3];\n        if (dirty &\n        /*step*/\n        2) shepherdcancelicon_changes.step =\n        /*step*/\n        ctx[1];\n        shepherdcancelicon.$set(shepherdcancelicon_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcancelicon.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcancelicon.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdcancelicon, detaching);\n      }\n    };\n  }\n\n  function create_fragment$4(ctx) {\n    var header;\n    var t;\n    var current;\n    var if_block0 =\n    /*title*/\n    ctx[2] && create_if_block_1(ctx);\n    var if_block1 =\n    /*cancelIcon*/\n    ctx[3] &&\n    /*cancelIcon*/\n    ctx[3].enabled && create_if_block$1(ctx);\n    return {\n      c: function c() {\n        header = element(\"header\");\n        if (if_block0) if_block0.c();\n        t = space();\n        if (if_block1) if_block1.c();\n        attr(header, \"class\", \"shepherd-header\");\n      },\n      m: function m(target, anchor) {\n        insert(target, header, anchor);\n        if (if_block0) if_block0.m(header, null);\n        append(header, t);\n        if (if_block1) if_block1.m(header, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var dirty = _ref[0];\n\n        if (\n        /*title*/\n        ctx[2]) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n\n            if (dirty &\n            /*title*/\n            4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_1(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(header, t);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n\n        if (\n        /*cancelIcon*/\n        ctx[3] &&\n        /*cancelIcon*/\n        ctx[3].enabled) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n\n            if (dirty &\n            /*cancelIcon*/\n            8) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block$1(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(header, null);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(header);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n      }\n    };\n  }\n\n  function instance$4($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n        step = $$props.step;\n    var title, cancelIcon;\n\n    $$self.$set = function ($$props) {\n      if (\"labelId\" in $$props) $$invalidate(0, labelId = $$props.labelId);\n      if (\"step\" in $$props) $$invalidate(1, step = $$props.step);\n    };\n\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty &\n      /*step*/\n      2) {\n        {\n          $$invalidate(2, title = step.options.title);\n          $$invalidate(3, cancelIcon = step.options.cancelIcon);\n        }\n      }\n    };\n\n    return [labelId, step, title, cancelIcon];\n  }\n\n  var Shepherd_header = /*#__PURE__*/function (_SvelteComponent) {\n    _inheritsLoose(Shepherd_header, _SvelteComponent);\n\n    function Shepherd_header(options) {\n      var _this;\n\n      _this = _SvelteComponent.call(this) || this;\n      init(_assertThisInitialized(_this), options, instance$4, create_fragment$4, safe_not_equal, {\n        labelId: 0,\n        step: 1\n      });\n      return _this;\n    }\n\n    return Shepherd_header;\n  }(SvelteComponent);\n\n  function create_fragment$5(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-text\");\n        attr(div, \"id\",\n        /*descriptionId*/\n        ctx[1]);\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        /*div_binding*/\n\n        ctx[3](div);\n      },\n      p: function p(ctx, _ref) {\n        var dirty = _ref[0];\n\n        if (dirty &\n        /*descriptionId*/\n        2) {\n          attr(div, \"id\",\n          /*descriptionId*/\n          ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        /*div_binding*/\n\n        ctx[3](null);\n      }\n    };\n  }\n\n  function instance$5($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n        element = $$props.element,\n        step = $$props.step;\n    afterUpdate(function () {\n      var text = step.options.text;\n\n      if (isFunction(text)) {\n        text = text.call(step);\n      }\n\n      if (isElement(text)) {\n        element.appendChild(text);\n      } else {\n        $$invalidate(0, element.innerHTML = text, element);\n      }\n    });\n\n    function div_binding($$value) {\n      binding_callbacks[$$value ? \"unshift\" : \"push\"](function () {\n        $$invalidate(0, element = $$value);\n      });\n    }\n\n    $$self.$set = function ($$props) {\n      if (\"descriptionId\" in $$props) $$invalidate(1, descriptionId = $$props.descriptionId);\n      if (\"element\" in $$props) $$invalidate(0, element = $$props.element);\n      if (\"step\" in $$props) $$invalidate(2, step = $$props.step);\n    };\n\n    return [element, descriptionId, step, div_binding];\n  }\n\n  var Shepherd_text = /*#__PURE__*/function (_SvelteComponent) {\n    _inheritsLoose(Shepherd_text, _SvelteComponent);\n\n    function Shepherd_text(options) {\n      var _this;\n\n      _this = _SvelteComponent.call(this) || this;\n      init(_assertThisInitialized(_this), options, instance$5, create_fragment$5, safe_not_equal, {\n        descriptionId: 1,\n        element: 0,\n        step: 2\n      });\n      return _this;\n    }\n\n    return Shepherd_text;\n  }(SvelteComponent);\n\n  function create_if_block_2(ctx) {\n    var current;\n    var shepherdheader = new Shepherd_header({\n      props: {\n        labelId:\n        /*labelId*/\n        ctx[1],\n        step:\n        /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdheader.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdheader, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdheader_changes = {};\n        if (dirty &\n        /*labelId*/\n        2) shepherdheader_changes.labelId =\n        /*labelId*/\n        ctx[1];\n        if (dirty &\n        /*step*/\n        4) shepherdheader_changes.step =\n        /*step*/\n        ctx[2];\n        shepherdheader.$set(shepherdheader_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdheader.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdheader.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdheader, detaching);\n      }\n    };\n  } // (29:2) {#if !isUndefined(step.options.text)}\n\n\n  function create_if_block_1$1(ctx) {\n    var current;\n    var shepherdtext = new Shepherd_text({\n      props: {\n        descriptionId:\n        /*descriptionId*/\n        ctx[0],\n        step:\n        /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtext.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtext, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtext_changes = {};\n        if (dirty &\n        /*descriptionId*/\n        1) shepherdtext_changes.descriptionId =\n        /*descriptionId*/\n        ctx[0];\n        if (dirty &\n        /*step*/\n        4) shepherdtext_changes.step =\n        /*step*/\n        ctx[2];\n        shepherdtext.$set(shepherdtext_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtext.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtext.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtext, detaching);\n      }\n    };\n  } // (36:2) {#if Array.isArray(step.options.buttons) && step.options.buttons.length}\n\n\n  function create_if_block$2(ctx) {\n    var current;\n    var shepherdfooter = new Shepherd_footer({\n      props: {\n        step:\n        /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdfooter.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdfooter, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdfooter_changes = {};\n        if (dirty &\n        /*step*/\n        4) shepherdfooter_changes.step =\n        /*step*/\n        ctx[2];\n        shepherdfooter.$set(shepherdfooter_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdfooter.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdfooter.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdfooter, detaching);\n      }\n    };\n  }\n\n  function create_fragment$6(ctx) {\n    var div;\n    var show_if_2 = !isUndefined(\n    /*step*/\n    ctx[2].options.title) ||\n    /*step*/\n    ctx[2].options.cancelIcon &&\n    /*step*/\n    ctx[2].options.cancelIcon.enabled;\n    var t0;\n    var show_if_1 = !isUndefined(\n    /*step*/\n    ctx[2].options.text);\n    var t1;\n    var show_if = Array.isArray(\n    /*step*/\n    ctx[2].options.buttons) &&\n    /*step*/\n    ctx[2].options.buttons.length;\n    var current;\n    var if_block0 = show_if_2 && create_if_block_2(ctx);\n    var if_block1 = show_if_1 && create_if_block_1$1(ctx);\n    var if_block2 = show_if && create_if_block$2(ctx);\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block0) if_block0.c();\n        t0 = space();\n        if (if_block1) if_block1.c();\n        t1 = space();\n        if (if_block2) if_block2.c();\n        attr(div, \"class\", \"shepherd-content\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        if (if_block0) if_block0.m(div, null);\n        append(div, t0);\n        if (if_block1) if_block1.m(div, null);\n        append(div, t1);\n        if (if_block2) if_block2.m(div, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var dirty = _ref[0];\n        if (dirty &\n        /*step*/\n        4) show_if_2 = !isUndefined(\n        /*step*/\n        ctx[2].options.title) ||\n        /*step*/\n        ctx[2].options.cancelIcon &&\n        /*step*/\n        ctx[2].options.cancelIcon.enabled;\n\n        if (show_if_2) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n\n            if (dirty &\n            /*step*/\n            4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_2(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(div, t0);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n\n        if (dirty &\n        /*step*/\n        4) show_if_1 = !isUndefined(\n        /*step*/\n        ctx[2].options.text);\n\n        if (show_if_1) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n\n            if (dirty &\n            /*step*/\n            4) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block_1$1(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(div, t1);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n\n        if (dirty &\n        /*step*/\n        4) show_if = Array.isArray(\n        /*step*/\n        ctx[2].options.buttons) &&\n        /*step*/\n        ctx[2].options.buttons.length;\n\n        if (show_if) {\n          if (if_block2) {\n            if_block2.p(ctx, dirty);\n\n            if (dirty &\n            /*step*/\n            4) {\n              transition_in(if_block2, 1);\n            }\n          } else {\n            if_block2 = create_if_block$2(ctx);\n            if_block2.c();\n            transition_in(if_block2, 1);\n            if_block2.m(div, null);\n          }\n        } else if (if_block2) {\n          group_outros();\n          transition_out(if_block2, 1, 1, function () {\n            if_block2 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        transition_in(if_block2);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        transition_out(if_block2);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n        if (if_block2) if_block2.d();\n      }\n    };\n  }\n\n  function instance$6($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n        labelId = $$props.labelId,\n        step = $$props.step;\n\n    $$self.$set = function ($$props) {\n      if (\"descriptionId\" in $$props) $$invalidate(0, descriptionId = $$props.descriptionId);\n      if (\"labelId\" in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if (\"step\" in $$props) $$invalidate(2, step = $$props.step);\n    };\n\n    return [descriptionId, labelId, step];\n  }\n\n  var Shepherd_content = /*#__PURE__*/function (_SvelteComponent) {\n    _inheritsLoose(Shepherd_content, _SvelteComponent);\n\n    function Shepherd_content(options) {\n      var _this;\n\n      _this = _SvelteComponent.call(this) || this;\n      init(_assertThisInitialized(_this), options, instance$6, create_fragment$6, safe_not_equal, {\n        descriptionId: 0,\n        labelId: 1,\n        step: 2\n      });\n      return _this;\n    }\n\n    return Shepherd_content;\n  }(SvelteComponent);\n\n  function create_if_block$3(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-arrow\");\n        attr(div, \"data-popper-arrow\", \"\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n      }\n    };\n  }\n\n  function create_fragment$7(ctx) {\n    var div;\n    var t;\n    var current;\n    var dispose;\n    var if_block =\n    /*step*/\n    ctx[4].options.arrow &&\n    /*step*/\n    ctx[4].options.attachTo &&\n    /*step*/\n    ctx[4].options.attachTo.element && create_if_block$3();\n    var shepherdcontent = new Shepherd_content({\n      props: {\n        descriptionId:\n        /*descriptionId*/\n        ctx[2],\n        labelId:\n        /*labelId*/\n        ctx[3],\n        step:\n        /*step*/\n        ctx[4]\n      }\n    });\n    var div_levels = [{\n      \"aria-describedby\": !isUndefined(\n      /*step*/\n      ctx[4].options.text) ?\n      /*descriptionId*/\n      ctx[2] : null\n    }, {\n      \"aria-labelledby\":\n      /*step*/\n      ctx[4].options.title ?\n      /*labelId*/\n      ctx[3] : null\n    },\n    /*dataStepId*/\n    ctx[1], {\n      role: \"dialog\"\n    }, {\n      tabindex: \"0\"\n    }];\n    var div_data = {};\n\n    for (var i = 0; i < div_levels.length; i += 1) {\n      div_data = assign(div_data, div_levels[i]);\n    }\n\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block) if_block.c();\n        t = space();\n        create_component(shepherdcontent.$$.fragment);\n        set_attributes(div, div_data);\n        toggle_class(div, \"shepherd-has-cancel-icon\",\n        /*hasCancelIcon*/\n        ctx[5]);\n        toggle_class(div, \"shepherd-has-title\",\n        /*hasTitle*/\n        ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      m: function m(target, anchor, remount) {\n        insert(target, div, anchor);\n        if (if_block) if_block.m(div, null);\n        append(div, t);\n        mount_component(shepherdcontent, div, null);\n        /*div_binding*/\n\n        ctx[17](div);\n        current = true;\n        if (remount) dispose();\n        dispose = listen(div, \"keydown\",\n        /*handleKeyDown*/\n        ctx[7]);\n      },\n      p: function p(ctx, _ref) {\n        var dirty = _ref[0];\n\n        if (\n        /*step*/\n        ctx[4].options.arrow &&\n        /*step*/\n        ctx[4].options.attachTo &&\n        /*step*/\n        ctx[4].options.attachTo.element) {\n          if (if_block) ;else {\n            if_block = create_if_block$3();\n            if_block.c();\n            if_block.m(div, t);\n          }\n        } else if (if_block) {\n          if_block.d(1);\n          if_block = null;\n        }\n\n        var shepherdcontent_changes = {};\n        if (dirty &\n        /*descriptionId*/\n        4) shepherdcontent_changes.descriptionId =\n        /*descriptionId*/\n        ctx[2];\n        if (dirty &\n        /*labelId*/\n        8) shepherdcontent_changes.labelId =\n        /*labelId*/\n        ctx[3];\n        if (dirty &\n        /*step*/\n        16) shepherdcontent_changes.step =\n        /*step*/\n        ctx[4];\n        shepherdcontent.$set(shepherdcontent_changes);\n        set_attributes(div, get_spread_update(div_levels, [dirty &\n        /*isUndefined, step, descriptionId*/\n        20 && {\n          \"aria-describedby\": !isUndefined(\n          /*step*/\n          ctx[4].options.text) ?\n          /*descriptionId*/\n          ctx[2] : null\n        }, dirty &\n        /*step, labelId*/\n        24 && {\n          \"aria-labelledby\":\n          /*step*/\n          ctx[4].options.title ?\n          /*labelId*/\n          ctx[3] : null\n        }, dirty &\n        /*dataStepId*/\n        2 &&\n        /*dataStepId*/\n        ctx[1], {\n          role: \"dialog\"\n        }, {\n          tabindex: \"0\"\n        }]));\n        toggle_class(div, \"shepherd-has-cancel-icon\",\n        /*hasCancelIcon*/\n        ctx[5]);\n        toggle_class(div, \"shepherd-has-title\",\n        /*hasTitle*/\n        ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcontent.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcontent.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block) if_block.d();\n        destroy_component(shepherdcontent);\n        /*div_binding*/\n\n        ctx[17](null);\n        dispose();\n      }\n    };\n  }\n\n  var KEY_TAB = 9;\n  var KEY_ESC = 27;\n  var LEFT_ARROW = 37;\n  var RIGHT_ARROW = 39;\n\n  function getClassesArray(classes) {\n    return classes.split(\" \").filter(function (className) {\n      return !!className.length;\n    });\n  }\n\n  function instance$7($$self, $$props, $$invalidate) {\n    var classPrefix = $$props.classPrefix,\n        element = $$props.element,\n        descriptionId = $$props.descriptionId,\n        firstFocusableElement = $$props.firstFocusableElement,\n        focusableElements = $$props.focusableElements,\n        labelId = $$props.labelId,\n        lastFocusableElement = $$props.lastFocusableElement,\n        step = $$props.step,\n        dataStepId = $$props.dataStepId;\n    var hasCancelIcon, hasTitle, classes;\n\n    var getElement = function getElement() {\n      return element;\n    };\n\n    onMount(function () {\n      var _dataStepId; // Get all elements that are focusable\n\n\n      $$invalidate(1, dataStepId = (_dataStepId = {}, _dataStepId[\"data-\" + classPrefix + \"shepherd-step-id\"] = step.id, _dataStepId));\n      $$invalidate(9, focusableElements = element.querySelectorAll(\"a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex=\\\"0\\\"]\"));\n      $$invalidate(8, firstFocusableElement = focusableElements[0]);\n      $$invalidate(10, lastFocusableElement = focusableElements[focusableElements.length - 1]);\n    });\n    afterUpdate(function () {\n      if (classes !== step.options.classes) {\n        updateDynamicClasses();\n      }\n    });\n\n    function updateDynamicClasses() {\n      removeClasses(classes);\n      classes = step.options.classes;\n      addClasses(classes);\n    }\n\n    function removeClasses(classes) {\n      if (isString(classes)) {\n        var oldClasses = getClassesArray(classes);\n\n        if (oldClasses.length) {\n          var _element$classList;\n\n          (_element$classList = element.classList).remove.apply(_element$classList, oldClasses);\n        }\n      }\n    }\n\n    function addClasses(classes) {\n      if (isString(classes)) {\n        var newClasses = getClassesArray(classes);\n\n        if (newClasses.length) {\n          var _element$classList2;\n\n          (_element$classList2 = element.classList).add.apply(_element$classList2, newClasses);\n        }\n      }\n    }\n    /**\n    * Setup keydown events to allow closing the modal with ESC\n    *\n    * Borrowed from this great post! https://bitsofco.de/accessible-modal-dialog/\n    *\n    * @private\n    */\n\n\n    var handleKeyDown = function handleKeyDown(e) {\n      var _step = step,\n          tour = _step.tour;\n\n      switch (e.keyCode) {\n        case KEY_TAB:\n          if (focusableElements.length === 0) {\n            e.preventDefault();\n            break;\n          } // Backward tab\n\n\n          if (e.shiftKey) {\n            if (document.activeElement === firstFocusableElement) {\n              e.preventDefault();\n              lastFocusableElement.focus();\n            }\n          } else {\n            if (document.activeElement === lastFocusableElement) {\n              e.preventDefault();\n              firstFocusableElement.focus();\n            }\n          }\n\n          break;\n\n        case KEY_ESC:\n          if (tour.options.exitOnEsc) {\n            step.cancel();\n          }\n\n          break;\n\n        case LEFT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            tour.back();\n          }\n\n          break;\n\n        case RIGHT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            tour.next();\n          }\n\n          break;\n      }\n    };\n\n    function div_binding($$value) {\n      binding_callbacks[$$value ? \"unshift\" : \"push\"](function () {\n        $$invalidate(0, element = $$value);\n      });\n    }\n\n    $$self.$set = function ($$props) {\n      if (\"classPrefix\" in $$props) $$invalidate(11, classPrefix = $$props.classPrefix);\n      if (\"element\" in $$props) $$invalidate(0, element = $$props.element);\n      if (\"descriptionId\" in $$props) $$invalidate(2, descriptionId = $$props.descriptionId);\n      if (\"firstFocusableElement\" in $$props) $$invalidate(8, firstFocusableElement = $$props.firstFocusableElement);\n      if (\"focusableElements\" in $$props) $$invalidate(9, focusableElements = $$props.focusableElements);\n      if (\"labelId\" in $$props) $$invalidate(3, labelId = $$props.labelId);\n      if (\"lastFocusableElement\" in $$props) $$invalidate(10, lastFocusableElement = $$props.lastFocusableElement);\n      if (\"step\" in $$props) $$invalidate(4, step = $$props.step);\n      if (\"dataStepId\" in $$props) $$invalidate(1, dataStepId = $$props.dataStepId);\n    };\n\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty &\n      /*step*/\n      16) {\n        {\n          $$invalidate(5, hasCancelIcon = step.options && step.options.cancelIcon && step.options.cancelIcon.enabled);\n          $$invalidate(6, hasTitle = step.options && step.options.title);\n        }\n      }\n    };\n\n    return [element, dataStepId, descriptionId, labelId, step, hasCancelIcon, hasTitle, handleKeyDown, firstFocusableElement, focusableElements, lastFocusableElement, classPrefix, getElement, classes, updateDynamicClasses, removeClasses, addClasses, div_binding];\n  }\n\n  var Shepherd_element = /*#__PURE__*/function (_SvelteComponent) {\n    _inheritsLoose(Shepherd_element, _SvelteComponent);\n\n    function Shepherd_element(options) {\n      var _this;\n\n      _this = _SvelteComponent.call(this) || this;\n      init(_assertThisInitialized(_this), options, instance$7, create_fragment$7, safe_not_equal, {\n        classPrefix: 11,\n        element: 0,\n        descriptionId: 2,\n        firstFocusableElement: 8,\n        focusableElements: 9,\n        labelId: 3,\n        lastFocusableElement: 10,\n        step: 4,\n        dataStepId: 1,\n        getElement: 12\n      });\n      return _this;\n    }\n\n    _createClass(Shepherd_element, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[12];\n      }\n    }]);\n\n    return Shepherd_element;\n  }(SvelteComponent);\n\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n\n  var smoothscroll = createCommonjsModule(function (module, exports) {\n    /* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */\n    (function () {\n      function polyfill() {\n        // aliases\n        var w = window;\n        var d = document; // return if scroll behavior is supported and polyfill is not forced\n\n        if ('scrollBehavior' in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {\n          return;\n        } // globals\n\n\n        var Element = w.HTMLElement || w.Element;\n        var SCROLL_TIME = 468; // object gathering original scroll methods\n\n        var original = {\n          scroll: w.scroll || w.scrollTo,\n          scrollBy: w.scrollBy,\n          elementScroll: Element.prototype.scroll || scrollElement,\n          scrollIntoView: Element.prototype.scrollIntoView\n        }; // define timing method\n\n        var now = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;\n        /**\n         * indicates if a the current browser is made by Microsoft\n         * @method isMicrosoftBrowser\n         * @param {String} userAgent\n         * @returns {Boolean}\n         */\n\n        function isMicrosoftBrowser(userAgent) {\n          var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n          return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n        }\n        /*\n         * IE has rounding bug rounding down clientHeight and clientWidth and\n         * rounding up scrollHeight and scrollWidth causing false positives\n         * on hasScrollableSpace\n         */\n\n\n        var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n        /**\n         * changes scroll position inside an element\n         * @method scrollElement\n         * @param {Number} x\n         * @param {Number} y\n         * @returns {undefined}\n         */\n\n        function scrollElement(x, y) {\n          this.scrollLeft = x;\n          this.scrollTop = y;\n        }\n        /**\n         * returns result of applying ease math function to a number\n         * @method ease\n         * @param {Number} k\n         * @returns {Number}\n         */\n\n\n        function ease(k) {\n          return 0.5 * (1 - Math.cos(Math.PI * k));\n        }\n        /**\n         * indicates if a smooth behavior should be applied\n         * @method shouldBailOut\n         * @param {Number|Object} firstArg\n         * @returns {Boolean}\n         */\n\n\n        function shouldBailOut(firstArg) {\n          if (firstArg === null || _typeof(firstArg) !== 'object' || firstArg.behavior === undefined || firstArg.behavior === 'auto' || firstArg.behavior === 'instant') {\n            // first argument is not an object/null\n            // or behavior is auto, instant or undefined\n            return true;\n          }\n\n          if (_typeof(firstArg) === 'object' && firstArg.behavior === 'smooth') {\n            // first argument is an object and behavior is smooth\n            return false;\n          } // throw error when behavior is not supported\n\n\n          throw new TypeError('behavior member of ScrollOptions ' + firstArg.behavior + ' is not a valid value for enumeration ScrollBehavior.');\n        }\n        /**\n         * indicates if an element has scrollable space in the provided axis\n         * @method hasScrollableSpace\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n\n        function hasScrollableSpace(el, axis) {\n          if (axis === 'Y') {\n            return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n          }\n\n          if (axis === 'X') {\n            return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n          }\n        }\n        /**\n         * indicates if an element has a scrollable overflow property in the axis\n         * @method canOverflow\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n\n        function canOverflow(el, axis) {\n          var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n          return overflowValue === 'auto' || overflowValue === 'scroll';\n        }\n        /**\n         * indicates if an element can be scrolled in either axis\n         * @method isScrollable\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n\n        function isScrollable(el) {\n          var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n          var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n          return isScrollableY || isScrollableX;\n        }\n        /**\n         * finds scrollable parent of an element\n         * @method findScrollableParent\n         * @param {Node} el\n         * @returns {Node} el\n         */\n\n\n        function findScrollableParent(el) {\n          while (el !== d.body && isScrollable(el) === false) {\n            el = el.parentNode || el.host;\n          }\n\n          return el;\n        }\n        /**\n         * self invoked function that, given a context, steps through scrolling\n         * @method step\n         * @param {Object} context\n         * @returns {undefined}\n         */\n\n\n        function step(context) {\n          var time = now();\n          var value;\n          var currentX;\n          var currentY;\n          var elapsed = (time - context.startTime) / SCROLL_TIME; // avoid elapsed times higher than one\n\n          elapsed = elapsed > 1 ? 1 : elapsed; // apply easing to elapsed time\n\n          value = ease(elapsed);\n          currentX = context.startX + (context.x - context.startX) * value;\n          currentY = context.startY + (context.y - context.startY) * value;\n          context.method.call(context.scrollable, currentX, currentY); // scroll more if we have not reached our destination\n\n          if (currentX !== context.x || currentY !== context.y) {\n            w.requestAnimationFrame(step.bind(w, context));\n          }\n        }\n        /**\n         * scrolls window or element with a smooth behavior\n         * @method smoothScroll\n         * @param {Object|Node} el\n         * @param {Number} x\n         * @param {Number} y\n         * @returns {undefined}\n         */\n\n\n        function smoothScroll(el, x, y) {\n          var scrollable;\n          var startX;\n          var startY;\n          var method;\n          var startTime = now(); // define scroll context\n\n          if (el === d.body) {\n            scrollable = w;\n            startX = w.scrollX || w.pageXOffset;\n            startY = w.scrollY || w.pageYOffset;\n            method = original.scroll;\n          } else {\n            scrollable = el;\n            startX = el.scrollLeft;\n            startY = el.scrollTop;\n            method = scrollElement;\n          } // scroll looping over a frame\n\n\n          step({\n            scrollable: scrollable,\n            method: method,\n            startTime: startTime,\n            startX: startX,\n            startY: startY,\n            x: x,\n            y: y\n          });\n        } // ORIGINAL METHODS OVERRIDES\n        // w.scroll and w.scrollTo\n\n\n        w.scroll = w.scrollTo = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n\n          if (shouldBailOut(arguments[0]) === true) {\n            original.scroll.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof(arguments[0]) !== 'object' ? arguments[0] : w.scrollX || w.pageXOffset, // use top prop, second argument if present or fallback to scrollY\n            arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : w.scrollY || w.pageYOffset);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n\n          smoothScroll.call(w, d.body, arguments[0].left !== undefined ? ~~arguments[0].left : w.scrollX || w.pageXOffset, arguments[0].top !== undefined ? ~~arguments[0].top : w.scrollY || w.pageYOffset);\n        }; // w.scrollBy\n\n\n        w.scrollBy = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n\n          if (shouldBailOut(arguments[0])) {\n            original.scrollBy.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof(arguments[0]) !== 'object' ? arguments[0] : 0, arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : 0);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n\n          smoothScroll.call(w, d.body, ~~arguments[0].left + (w.scrollX || w.pageXOffset), ~~arguments[0].top + (w.scrollY || w.pageYOffset));\n        }; // Element.prototype.scroll and Element.prototype.scrollTo\n\n\n        Element.prototype.scroll = Element.prototype.scrollTo = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n\n          if (shouldBailOut(arguments[0]) === true) {\n            // if one number is passed, throw error to match Firefox implementation\n            if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n              throw new SyntaxError('Value could not be converted');\n            }\n\n            original.elementScroll.call(this, // use left prop, first number argument or fallback to scrollLeft\n            arguments[0].left !== undefined ? ~~arguments[0].left : _typeof(arguments[0]) !== 'object' ? ~~arguments[0] : this.scrollLeft, // use top prop, second argument or fallback to scrollTop\n            arguments[0].top !== undefined ? ~~arguments[0].top : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop);\n            return;\n          }\n\n          var left = arguments[0].left;\n          var top = arguments[0].top; // LET THE SMOOTHNESS BEGIN!\n\n          smoothScroll.call(this, this, typeof left === 'undefined' ? this.scrollLeft : ~~left, typeof top === 'undefined' ? this.scrollTop : ~~top);\n        }; // Element.prototype.scrollBy\n\n\n        Element.prototype.scrollBy = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n\n          if (shouldBailOut(arguments[0]) === true) {\n            original.elementScroll.call(this, arguments[0].left !== undefined ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, arguments[0].top !== undefined ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop);\n            return;\n          }\n\n          this.scroll({\n            left: ~~arguments[0].left + this.scrollLeft,\n            top: ~~arguments[0].top + this.scrollTop,\n            behavior: arguments[0].behavior\n          });\n        }; // Element.prototype.scrollIntoView\n\n\n        Element.prototype.scrollIntoView = function () {\n          // avoid smooth behavior if not required\n          if (shouldBailOut(arguments[0]) === true) {\n            original.scrollIntoView.call(this, arguments[0] === undefined ? true : arguments[0]);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n\n          var scrollableParent = findScrollableParent(this);\n          var parentRects = scrollableParent.getBoundingClientRect();\n          var clientRects = this.getBoundingClientRect();\n\n          if (scrollableParent !== d.body) {\n            // reveal element inside parent\n            smoothScroll.call(this, scrollableParent, scrollableParent.scrollLeft + clientRects.left - parentRects.left, scrollableParent.scrollTop + clientRects.top - parentRects.top); // reveal parent in viewport unless is fixed\n\n            if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n              w.scrollBy({\n                left: parentRects.left,\n                top: parentRects.top,\n                behavior: 'smooth'\n              });\n            }\n          } else {\n            // reveal element in viewport\n            w.scrollBy({\n              left: clientRects.left,\n              top: clientRects.top,\n              behavior: 'smooth'\n            });\n          }\n        };\n      }\n\n      {\n        // commonjs\n        module.exports = {\n          polyfill: polyfill\n        };\n      }\n    })();\n  });\n  var smoothscroll_1 = smoothscroll.polyfill;\n  smoothscroll.polyfill();\n  /**\n   * A class representing steps to be added to a tour.\n   * @extends {Evented}\n   */\n\n  var Step = /*#__PURE__*/function (_Evented) {\n    _inheritsLoose(Step, _Evented);\n    /**\n     * Create a step\n     * @param {Tour} tour The tour for the step\n     * @param {Object} options The options for the step\n     * @param {boolean} options.arrow Whether to display the arrow for the tooltip or not. Defaults to `true`.\n     * @param {Object} options.attachTo What element the step should be attached to on the page.\n     * It should be an object with the properties `element` and `on`, where `element` is an element selector string\n     * or a DOM element and `on` is the optional direction to place the Popper tooltip.\n     *\n     * ```js\n     * const step = new Step(tour, {\n     *   attachTo: { element: '.some .selector-path', on: 'left' },\n     *   ...moreOptions\n     * });\n     * ```\n     *\n     * If you don’t specify an attachTo the element will appear in the middle of the screen.\n     * If you omit the `on` portion of `attachTo`, the element will still be highlighted, but the tooltip will appear\n     * in the middle of the screen, without an arrow pointing to the target.\n     * @param {HTMLElement|string} options.attachTo.element\n     * @param {string} options.attachTo.on\n     * @param {Object} options.advanceOn An action on the page which should advance shepherd to the next step.\n     * It should be an object with a string `selector` and an `event` name\n     * ```js\n     * const step = new Step(tour, {\n     *   advanceOn: { selector: '.some .selector-path', event: 'click' },\n     *   ...moreOptions\n     * });\n     * ```\n     * `event` doesn’t have to be an event inside the tour, it can be any event fired on any element on the page.\n     * You can also always manually advance the Tour by calling `myTour.next()`.\n     * @param {function} options.beforeShowPromise A function that returns a promise.\n     * When the promise resolves, the rest of the `show` code for the step will execute.\n     * @param {Object[]} options.buttons An array of buttons to add to the step. These will be rendered in a\n     * footer below the main body text.\n     * @param {function} options.buttons.button.action A function executed when the button is clicked on.\n     * It is automatically bound to the `tour` the step is associated with, so things like `this.next` will\n     * work inside the action.\n     * You can use action to skip steps or navigate to specific steps, with something like:\n     * ```js\n     * action() {\n     *   return this.show('some_step_name');\n     * }\n     * ```\n     * @param {string} options.buttons.button.classes Extra classes to apply to the `<a>`\n     * @param {boolean} options.buttons.button.secondary If true, a shepherd-button-secondary class is applied to the button\n     * @param {string} options.buttons.button.text The HTML text of the button\n     * @param {boolean} options.buttons.button.disabled Should the button be disabled?\n     * @param {string} options.buttons.button.label The aria-label text of the button\n     * @param {boolean} options.canClickTarget A boolean, that when set to false, will set `pointer-events: none` on the target\n     * @param {object} options.cancelIcon Options for the cancel icon\n     * @param {boolean} options.cancelIcon.enabled Should a cancel “✕” be shown in the header of the step?\n     * @param {string} options.cancelIcon.label The label to add for `aria-label`\n     * @param {string} options.classes A string of extra classes to add to the step's content element.\n     * @param {string} options.highlightClass An extra class to apply to the `attachTo` element when it is\n     * highlighted (that is, when its step is active). You can then target that selector in your CSS.\n     * @param {string} options.id The string to use as the `id` for the step.\n     * @param {object} options.popperOptions Extra options to pass to Popper\n     * @param {boolean|Object} options.scrollTo Should the element be scrolled to when this step is shown? If true, uses the default `scrollIntoView`,\n     * if an object, passes that object as the params to `scrollIntoView` i.e. `{behavior: 'smooth', block: 'center'}`\n     * @param {function} options.scrollToHandler A function that lets you override the default scrollTo behavior and\n     * define a custom action to do the scrolling, and possibly other logic.\n     * @param {function} options.showOn A function that, when it returns `true`, will show the step.\n     * If it returns false, the step will be skipped.\n     * @param {string} options.text The text in the body of the step. It can be one of three types:\n     * ```\n     * - HTML string\n     * - `HTMLElement` object\n     * - `Function` to be executed when the step is built. It must return one the two options above.\n     * ```\n     * @param {string} options.title The step's title. It becomes an `h3` at the top of the step. It can be one of two types:\n     * ```\n     * - HTML string\n     * - `Function` to be executed when the step is built. It must return HTML string.\n     * ```\n     * @param {Object} options.when You can define `show`, `hide`, etc events inside `when`. For example:\n     * ```js\n     * when: {\n     *   show: function() {\n     *     window.scrollTo(0, 0);\n     *   }\n     * }\n     * ```\n     * @param {Number} options.modalOverlayOpeningPadding An amount of padding to add around the modal overlay opening\n     * @param {Number} options.modalOverlayOpeningRadius An amount of border radius to add around the modal overlay opening\n     * @return {Step} The newly created Step instance\n     */\n\n\n    function Step(tour, options) {\n      var _this;\n\n      if (options === void 0) {\n        options = {};\n      }\n\n      _this = _Evented.call(this, tour, options) || this;\n      _this.tour = tour;\n      _this.classPrefix = _this.tour.options ? normalizePrefix(_this.tour.options.classPrefix) : '';\n      _this.styles = tour.styles;\n      autoBind(_assertThisInitialized(_this));\n\n      _this._setOptions(options);\n\n      return _assertThisInitialized(_this) || _assertThisInitialized(_this);\n    }\n    /**\n     * Cancel the tour\n     * Triggers the `cancel` event\n     */\n\n\n    var _proto = Step.prototype;\n\n    _proto.cancel = function cancel() {\n      this.tour.cancel();\n      this.trigger('cancel');\n    }\n    /**\n     * Complete the tour\n     * Triggers the `complete` event\n     */\n    ;\n\n    _proto.complete = function complete() {\n      this.tour.complete();\n      this.trigger('complete');\n    }\n    /**\n     * Remove the step, delete the step's element, and destroy the Popper instance for the step.\n     * Triggers `destroy` event\n     */\n    ;\n\n    _proto.destroy = function destroy() {\n      if (this.tooltip) {\n        this.tooltip.destroy();\n        this.tooltip = null;\n      }\n\n      if (isElement(this.el) && this.el.parentNode) {\n        this.el.parentNode.removeChild(this.el);\n        this.el = null;\n      }\n\n      if (this.target) {\n        this._updateStepTargetOnHide();\n      }\n\n      this.trigger('destroy');\n    }\n    /**\n     * Returns the tour for the step\n     * @return {Tour} The tour instance\n     */\n    ;\n\n    _proto.getTour = function getTour() {\n      return this.tour;\n    }\n    /**\n     * Hide the step\n     */\n    ;\n\n    _proto.hide = function hide() {\n      this.tour.modal.hide();\n      this.trigger('before-hide');\n\n      if (this.el) {\n        this.el.hidden = true;\n      }\n\n      if (this.target) {\n        this._updateStepTargetOnHide();\n      }\n\n      this.trigger('hide');\n    }\n    /**\n     * Checks if the step should be centered or not\n     * @return {boolean} True if the step is centered\n     */\n    ;\n\n    _proto.isCentered = function isCentered() {\n      var attachToOptions = parseAttachTo(this);\n      return !attachToOptions.element || !attachToOptions.on;\n    }\n    /**\n     * Check if the step is open and visible\n     * @return {boolean} True if the step is open and visible\n     */\n    ;\n\n    _proto.isOpen = function isOpen() {\n      return Boolean(this.el && !this.el.hidden);\n    }\n    /**\n     * Wraps `_show` and ensures `beforeShowPromise` resolves before calling show\n     * @return {*|Promise}\n     */\n    ;\n\n    _proto.show = function show() {\n      var _this2 = this;\n\n      if (isFunction(this.options.beforeShowPromise)) {\n        var beforeShowPromise = this.options.beforeShowPromise();\n\n        if (!isUndefined(beforeShowPromise)) {\n          return beforeShowPromise.then(function () {\n            return _this2._show();\n          });\n        }\n      }\n\n      this._show();\n    }\n    /**\n     * Updates the options of the step.\n     *\n     * @param {Object} options The options for the step\n     */\n    ;\n\n    _proto.updateStepOptions = function updateStepOptions(options) {\n      Object.assign(this.options, options);\n\n      if (this.shepherdElementComponent) {\n        this.shepherdElementComponent.$set({\n          step: this\n        });\n      }\n    }\n    /**\n     * Creates Shepherd element for step based on options\n     *\n     * @return {Element} The DOM element for the step tooltip\n     * @private\n     */\n    ;\n\n    _proto._createTooltipContent = function _createTooltipContent() {\n      var descriptionId = this.id + \"-description\";\n      var labelId = this.id + \"-label\";\n      this.shepherdElementComponent = new Shepherd_element({\n        target: document.body,\n        props: {\n          classPrefix: this.classPrefix,\n          descriptionId: descriptionId,\n          labelId: labelId,\n          step: this,\n          styles: this.styles\n        }\n      });\n      return this.shepherdElementComponent.getElement();\n    }\n    /**\n     * If a custom scrollToHandler is defined, call that, otherwise do the generic\n     * scrollIntoView call.\n     *\n     * @param {boolean|Object} scrollToOptions If true, uses the default `scrollIntoView`,\n     * if an object, passes that object as the params to `scrollIntoView` i.e. `{ behavior: 'smooth', block: 'center' }`\n     * @private\n     */\n    ;\n\n    _proto._scrollTo = function _scrollTo(scrollToOptions) {\n      var _parseAttachTo = parseAttachTo(this),\n          element = _parseAttachTo.element;\n\n      if (isFunction(this.options.scrollToHandler)) {\n        this.options.scrollToHandler(element);\n      } else if (isElement(element) && typeof element.scrollIntoView === 'function') {\n        element.scrollIntoView(scrollToOptions);\n      }\n    }\n    /**\n     * _getClassOptions gets all possible classes for the step\n     * @param {Object} stepOptions The step specific options\n     * @returns {String} unique string from array of classes\n     * @private\n     */\n    ;\n\n    _proto._getClassOptions = function _getClassOptions(stepOptions) {\n      var defaultStepOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n      var stepClasses = stepOptions.classes ? stepOptions.classes : '';\n      var defaultStepOptionsClasses = defaultStepOptions && defaultStepOptions.classes ? defaultStepOptions.classes : '';\n      var allClasses = [].concat(stepClasses.split(' '), defaultStepOptionsClasses.split(' '));\n      var uniqClasses = new Set(allClasses);\n      return Array.from(uniqClasses).join(' ').trim();\n    }\n    /**\n     * Sets the options for the step, maps `when` to events, sets up buttons\n     * @param {Object} options The options for the step\n     * @private\n     */\n    ;\n\n    _proto._setOptions = function _setOptions(options) {\n      var _this3 = this;\n\n      if (options === void 0) {\n        options = {};\n      }\n\n      var tourOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n      tourOptions = tourOptions ? JSON.parse(JSON.stringify(tourOptions)) : {};\n      this.options = Object.assign({\n        arrow: true\n      }, tourOptions, options);\n      var when = this.options.when;\n      this.options.classes = this._getClassOptions(options);\n      this.destroy();\n      this.id = this.options.id || \"step-\" + uuid();\n\n      if (when) {\n        Object.keys(when).forEach(function (event) {\n          _this3.on(event, when[event], _this3);\n        });\n      }\n    }\n    /**\n     * Create the element and set up the Popper instance\n     * @private\n     */\n    ;\n\n    _proto._setupElements = function _setupElements() {\n      if (!isUndefined(this.el)) {\n        this.destroy();\n      }\n\n      this.el = this._createTooltipContent();\n\n      if (this.options.advanceOn) {\n        bindAdvance(this);\n      }\n\n      setupTooltip(this);\n    }\n    /**\n     * Triggers `before-show`, generates the tooltip DOM content,\n     * sets up a Popper instance for the tooltip, then triggers `show`.\n     * @private\n     */\n    ;\n\n    _proto._show = function _show() {\n      var _this4 = this;\n\n      this.trigger('before-show');\n\n      this._setupElements();\n\n      if (!this.tour.modal) {\n        this.tour._setupModal();\n      }\n\n      this.tour.modal.setupForStep(this);\n\n      this._styleTargetElementForStep(this);\n\n      this.el.hidden = false; // start scrolling to target before showing the step\n\n      if (this.options.scrollTo) {\n        setTimeout(function () {\n          _this4._scrollTo(_this4.options.scrollTo);\n        });\n      }\n\n      this.el.hidden = false;\n      var content = this.shepherdElementComponent.getElement();\n      var target = this.target || document.body;\n      target.classList.add(this.classPrefix + \"shepherd-enabled\");\n      target.classList.add(this.classPrefix + \"shepherd-target\");\n      content.classList.add('shepherd-enabled');\n      this.trigger('show');\n    }\n    /**\n     * Modulates the styles of the passed step's target element, based on the step's options and\n     * the tour's `modal` option, to visually emphasize the element\n     *\n     * @param step The step object that attaches to the element\n     * @private\n     */\n    ;\n\n    _proto._styleTargetElementForStep = function _styleTargetElementForStep(step) {\n      var targetElement = step.target;\n\n      if (!targetElement) {\n        return;\n      }\n\n      if (step.options.highlightClass) {\n        targetElement.classList.add(step.options.highlightClass);\n      }\n\n      if (step.options.canClickTarget === false) {\n        targetElement.classList.add('shepherd-target-click-disabled');\n      }\n    }\n    /**\n     * When a step is hidden, remove the highlightClass and 'shepherd-enabled'\n     * and 'shepherd-target' classes\n     * @private\n     */\n    ;\n\n    _proto._updateStepTargetOnHide = function _updateStepTargetOnHide() {\n      if (this.options.highlightClass) {\n        this.target.classList.remove(this.options.highlightClass);\n      }\n\n      this.target.classList.remove(this.classPrefix + \"shepherd-enabled\", this.classPrefix + \"shepherd-target\");\n    };\n\n    return Step;\n  }(Evented);\n  /**\n   * Cleanup the steps and set pointerEvents back to 'auto'\n   * @param tour The tour object\n   */\n\n\n  function cleanupSteps(tour) {\n    if (tour) {\n      var steps = tour.steps;\n      steps.forEach(function (step) {\n        if (step.options && step.options.canClickTarget === false && step.options.attachTo) {\n          if (step.target instanceof HTMLElement) {\n            step.target.classList.remove('shepherd-target-click-disabled');\n          }\n        }\n      });\n    }\n  }\n  /**\n   * Generates the svg path data for a rounded rectangle overlay\n   * @param {Object} dimension - Dimensions of rectangle.\n   * @param {number} width - Width.\n   * @param {number} height - Height.\n   * @param {number} [x=0] - Offset from top left corner in x axis. default 0.\n   * @param {number} [y=0] - Offset from top left corner in y axis. default 0.\n   * @param {number} [r=0] - Corner Radius. Keep this smaller than  half of width or height.\n   * @returns {string} - Rounded rectangle overlay path data.\n   */\n\n\n  function makeOverlayPath(_ref) {\n    var width = _ref.width,\n        height = _ref.height,\n        _ref$x = _ref.x,\n        x = _ref$x === void 0 ? 0 : _ref$x,\n        _ref$y = _ref.y,\n        y = _ref$y === void 0 ? 0 : _ref$y,\n        _ref$r = _ref.r,\n        r = _ref$r === void 0 ? 0 : _ref$r;\n    var _window = window,\n        w = _window.innerWidth,\n        h = _window.innerHeight;\n    return \"M\" + w + \",\" + h + \"H0V0H\" + w + \"V\" + h + \"ZM\" + (x + r) + \",\" + y + \"a\" + r + \",\" + r + \",0,0,0-\" + r + \",\" + r + \"V\" + (height + y - r) + \"a\" + r + \",\" + r + \",0,0,0,\" + r + \",\" + r + \"H\" + (width + x - r) + \"a\" + r + \",\" + r + \",0,0,0,\" + r + \"-\" + r + \"V\" + (y + r) + \"a\" + r + \",\" + r + \",0,0,0-\" + r + \"-\" + r + \"Z\";\n  }\n\n  function create_fragment$8(ctx) {\n    var svg;\n    var path;\n    var svg_class_value;\n    var dispose;\n    return {\n      c: function c() {\n        svg = svg_element(\"svg\");\n        path = svg_element(\"path\");\n        attr(path, \"d\",\n        /*pathDefinition*/\n        ctx[2]);\n        attr(svg, \"class\", svg_class_value = (\n        /*modalIsVisible*/\n        ctx[1] ? \"shepherd-modal-is-visible\" : \"\") + \" shepherd-modal-overlay-container\");\n      },\n      m: function m(target, anchor, remount) {\n        insert(target, svg, anchor);\n        append(svg, path);\n        /*svg_binding*/\n\n        ctx[17](svg);\n        if (remount) dispose();\n        dispose = listen(svg, \"touchmove\",\n        /*_preventModalOverlayTouch*/\n        ctx[3]);\n      },\n      p: function p(ctx, _ref) {\n        var dirty = _ref[0];\n\n        if (dirty &\n        /*pathDefinition*/\n        4) {\n          attr(path, \"d\",\n          /*pathDefinition*/\n          ctx[2]);\n        }\n\n        if (dirty &\n        /*modalIsVisible*/\n        2 && svg_class_value !== (svg_class_value = (\n        /*modalIsVisible*/\n        ctx[1] ? \"shepherd-modal-is-visible\" : \"\") + \" shepherd-modal-overlay-container\")) {\n          attr(svg, \"class\", svg_class_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(svg);\n        /*svg_binding*/\n\n        ctx[17](null);\n        dispose();\n      }\n    };\n  }\n\n  function _getScrollParent(element) {\n    if (!element) {\n      return null;\n    }\n\n    var isHtmlElement = element instanceof HTMLElement;\n    var overflowY = isHtmlElement && window.getComputedStyle(element).overflowY;\n    var isScrollable = overflowY !== \"hidden\" && overflowY !== \"visible\";\n\n    if (isScrollable && element.scrollHeight >= element.clientHeight) {\n      return element;\n    }\n\n    return _getScrollParent(element.parentElement);\n  }\n  /**\n  * Get the visible height of the target element relative to its scrollParent.\n  * If there is no scroll parent, the height of the element is returned.\n  *\n  * @param {HTMLElement} element The target element\n  * @param {HTMLElement} [scrollParent] The scrollable parent element\n  * @returns {{y: number, height: number}}\n  * @private\n  */\n\n\n  function _getVisibleHeight(element, scrollParent) {\n    var elementRect = element.getBoundingClientRect();\n    var top = elementRect.y || elementRect.top;\n    var bottom = elementRect.bottom || top + elementRect.height;\n\n    if (scrollParent) {\n      var scrollRect = scrollParent.getBoundingClientRect();\n      var scrollTop = scrollRect.y || scrollRect.top;\n      var scrollBottom = scrollRect.bottom || scrollTop + scrollRect.height;\n      top = Math.max(top, scrollTop);\n      bottom = Math.min(bottom, scrollBottom);\n    }\n\n    var height = Math.max(bottom - top, 0); // Default to 0 if height is negative\n\n    return {\n      y: top,\n      height: height\n    };\n  }\n\n  function instance$8($$self, $$props, $$invalidate) {\n    var element = $$props.element,\n        openingProperties = $$props.openingProperties;\n    var guid = uuid();\n    var modalIsVisible = false;\n    var rafId = undefined;\n    var pathDefinition;\n    closeModalOpening();\n\n    var getElement = function getElement() {\n      return element;\n    };\n\n    function closeModalOpening() {\n      $$invalidate(4, openingProperties = {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0,\n        r: 0\n      });\n    }\n\n    function hide() {\n      $$invalidate(1, modalIsVisible = false); // Ensure we cleanup all event listeners when we hide the modal\n\n      _cleanupStepEventListeners();\n    }\n\n    function positionModalOpening(targetElement, scrollParent, modalOverlayOpeningPadding, modalOverlayOpeningRadius) {\n      if (modalOverlayOpeningPadding === void 0) {\n        modalOverlayOpeningPadding = 0;\n      }\n\n      if (modalOverlayOpeningRadius === void 0) {\n        modalOverlayOpeningRadius = 0;\n      }\n\n      if (targetElement.getBoundingClientRect) {\n        var _getVisibleHeight2 = _getVisibleHeight(targetElement, scrollParent),\n            y = _getVisibleHeight2.y,\n            height = _getVisibleHeight2.height;\n\n        var _targetElement$getBou = targetElement.getBoundingClientRect(),\n            x = _targetElement$getBou.x,\n            width = _targetElement$getBou.width,\n            left = _targetElement$getBou.left; // getBoundingClientRect is not consistent. Some browsers use x and y, while others use left and top\n\n\n        $$invalidate(4, openingProperties = {\n          width: width + modalOverlayOpeningPadding * 2,\n          height: height + modalOverlayOpeningPadding * 2,\n          x: (x || left) - modalOverlayOpeningPadding,\n          y: y - modalOverlayOpeningPadding,\n          r: modalOverlayOpeningRadius\n        });\n      }\n    }\n\n    function setupForStep(step) {\n      // Ensure we move listeners from the previous step, before we setup new ones\n      _cleanupStepEventListeners();\n\n      if (step.tour.options.useModalOverlay) {\n        _styleForStep(step);\n\n        show();\n      } else {\n        hide();\n      }\n    }\n\n    function show() {\n      $$invalidate(1, modalIsVisible = true);\n    }\n\n    var _preventModalBodyTouch = function _preventModalBodyTouch(e) {\n      e.preventDefault();\n    };\n\n    var _preventModalOverlayTouch = function _preventModalOverlayTouch(e) {\n      e.stopPropagation();\n    };\n    /**\n    * Add touchmove event listener\n    * @private\n    */\n\n\n    function _addStepEventListeners() {\n      // Prevents window from moving on touch.\n      window.addEventListener(\"touchmove\", _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n    /**\n    * Cancel the requestAnimationFrame loop and remove touchmove event listeners\n    * @private\n    */\n\n\n    function _cleanupStepEventListeners() {\n      if (rafId) {\n        cancelAnimationFrame(rafId);\n        rafId = undefined;\n      }\n\n      window.removeEventListener(\"touchmove\", _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n    /**\n    * Style the modal for the step\n    * @param {Step} step The step to style the opening for\n    * @private\n    */\n\n\n    function _styleForStep(step) {\n      var _step$options = step.options,\n          modalOverlayOpeningPadding = _step$options.modalOverlayOpeningPadding,\n          modalOverlayOpeningRadius = _step$options.modalOverlayOpeningRadius;\n\n      if (step.target) {\n        var scrollParent = _getScrollParent(step.target); // Setup recursive function to call requestAnimationFrame to update the modal opening position\n\n\n        var rafLoop = function rafLoop() {\n          rafId = undefined;\n          positionModalOpening(step.target, scrollParent, modalOverlayOpeningPadding, modalOverlayOpeningRadius);\n          rafId = requestAnimationFrame(rafLoop);\n        };\n\n        rafLoop();\n\n        _addStepEventListeners();\n      } else {\n        closeModalOpening();\n      }\n    }\n\n    function svg_binding($$value) {\n      binding_callbacks[$$value ? \"unshift\" : \"push\"](function () {\n        $$invalidate(0, element = $$value);\n      });\n    }\n\n    $$self.$set = function ($$props) {\n      if (\"element\" in $$props) $$invalidate(0, element = $$props.element);\n      if (\"openingProperties\" in $$props) $$invalidate(4, openingProperties = $$props.openingProperties);\n    };\n\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty &\n      /*openingProperties*/\n      16) {\n        $$invalidate(2, pathDefinition = makeOverlayPath(openingProperties));\n      }\n    };\n\n    return [element, modalIsVisible, pathDefinition, _preventModalOverlayTouch, openingProperties, getElement, closeModalOpening, hide, positionModalOpening, setupForStep, show, rafId, guid, _preventModalBodyTouch, _addStepEventListeners, _cleanupStepEventListeners, _styleForStep, svg_binding];\n  }\n\n  var Shepherd_modal = /*#__PURE__*/function (_SvelteComponent) {\n    _inheritsLoose(Shepherd_modal, _SvelteComponent);\n\n    function Shepherd_modal(options) {\n      var _this;\n\n      _this = _SvelteComponent.call(this) || this;\n      init(_assertThisInitialized(_this), options, instance$8, create_fragment$8, safe_not_equal, {\n        element: 0,\n        openingProperties: 4,\n        getElement: 5,\n        closeModalOpening: 6,\n        hide: 7,\n        positionModalOpening: 8,\n        setupForStep: 9,\n        show: 10\n      });\n      return _this;\n    }\n\n    _createClass(Shepherd_modal, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[5];\n      }\n    }, {\n      key: \"closeModalOpening\",\n      get: function get() {\n        return this.$$.ctx[6];\n      }\n    }, {\n      key: \"hide\",\n      get: function get() {\n        return this.$$.ctx[7];\n      }\n    }, {\n      key: \"positionModalOpening\",\n      get: function get() {\n        return this.$$.ctx[8];\n      }\n    }, {\n      key: \"setupForStep\",\n      get: function get() {\n        return this.$$.ctx[9];\n      }\n    }, {\n      key: \"show\",\n      get: function get() {\n        return this.$$.ctx[10];\n      }\n    }]);\n\n    return Shepherd_modal;\n  }(SvelteComponent);\n\n  var Shepherd = new Evented();\n  /**\n   * Class representing the site tour\n   * @extends {Evented}\n   */\n\n  var Tour = /*#__PURE__*/function (_Evented) {\n    _inheritsLoose(Tour, _Evented);\n    /**\n     * @param {Object} options The options for the tour\n     * @param {boolean} options.confirmCancel If true, will issue a `window.confirm` before cancelling\n     * @param {string} options.confirmCancelMessage The message to display in the confirm dialog\n     * @param {string} options.classPrefix The prefix to add to the `shepherd-enabled` and `shepherd-target` class names as well as the `data-shepherd-step-id`.\n     * @param {Object} options.defaultStepOptions Default options for Steps ({@link Step#constructor}), created through `addStep`\n     * @param {boolean} options.exitOnEsc Exiting the tour with the escape key will be enabled unless this is explicitly\n     * set to false.\n     * @param {boolean} options.keyboardNavigation Navigating the tour via left and right arrow keys will be enabled\n     * unless this is explicitly set to false.\n     * @param {HTMLElement} options.modalContainer An optional container element for the modal.\n     * If not set, the modal will be appended to `document.body`.\n     * @param {object[] | Step[]} options.steps An array of step options objects or Step instances to initialize the tour with\n     * @param {string} options.tourName An optional \"name\" for the tour. This will be appended to the the tour's\n     * dynamically generated `id` property -- which is also set on the `body` element as the `data-shepherd-active-tour` attribute\n     * whenever the tour becomes active.\n     * @param {boolean} options.useModalOverlay Whether or not steps should be placed above a darkened\n     * modal overlay. If true, the overlay will create an opening around the target element so that it\n     * can remain interactive\n     * @returns {Tour}\n     */\n\n\n    function Tour(options) {\n      var _this;\n\n      if (options === void 0) {\n        options = {};\n      }\n\n      _this = _Evented.call(this, options) || this;\n      autoBind(_assertThisInitialized(_this));\n      var defaultTourOptions = {\n        exitOnEsc: true,\n        keyboardNavigation: true\n      };\n      _this.options = Object.assign({}, defaultTourOptions, options);\n      _this.classPrefix = normalizePrefix(_this.options.classPrefix);\n      _this.steps = [];\n\n      _this.addSteps(_this.options.steps); // Pass these events onto the global Shepherd object\n\n\n      var events = ['active', 'cancel', 'complete', 'inactive', 'show', 'start'];\n      events.map(function (event) {\n        (function (e) {\n          _this.on(e, function (opts) {\n            opts = opts || {};\n            opts.tour = _assertThisInitialized(_this);\n            Shepherd.trigger(e, opts);\n          });\n        })(event);\n      });\n\n      _this._setTourID();\n\n      return _assertThisInitialized(_this) || _assertThisInitialized(_this);\n    }\n    /**\n     * Adds a new step to the tour\n     * @param {Object|Step} options An object containing step options or a Step instance\n     * @param {number} index The optional index to insert the step at. If undefined, the step\n     * is added to the end of the array.\n     * @return {Step} The newly added step\n     */\n\n\n    var _proto = Tour.prototype;\n\n    _proto.addStep = function addStep(options, index) {\n      var step = options;\n\n      if (!(step instanceof Step)) {\n        step = new Step(this, step);\n      } else {\n        step.tour = this;\n      }\n\n      if (!isUndefined(index)) {\n        this.steps.splice(index, 0, step);\n      } else {\n        this.steps.push(step);\n      }\n\n      return step;\n    }\n    /**\n     * Add multiple steps to the tour\n     * @param {Array<object> | Array<Step>} steps The steps to add to the tour\n     */\n    ;\n\n    _proto.addSteps = function addSteps(steps) {\n      var _this2 = this;\n\n      if (Array.isArray(steps)) {\n        steps.forEach(function (step) {\n          _this2.addStep(step);\n        });\n      }\n\n      return this;\n    }\n    /**\n     * Go to the previous step in the tour\n     */\n    ;\n\n    _proto.back = function back() {\n      var index = this.steps.indexOf(this.currentStep);\n      this.show(index - 1, false);\n    }\n    /**\n     * Calls _done() triggering the 'cancel' event\n     * If `confirmCancel` is true, will show a window.confirm before cancelling\n     */\n    ;\n\n    _proto.cancel = function cancel() {\n      if (this.options.confirmCancel) {\n        var cancelMessage = this.options.confirmCancelMessage || 'Are you sure you want to stop the tour?';\n        var stopTour = window.confirm(cancelMessage);\n\n        if (stopTour) {\n          this._done('cancel');\n        }\n      } else {\n        this._done('cancel');\n      }\n    }\n    /**\n     * Calls _done() triggering the `complete` event\n     */\n    ;\n\n    _proto.complete = function complete() {\n      this._done('complete');\n    }\n    /**\n     * Gets the step from a given id\n     * @param {Number|String} id The id of the step to retrieve\n     * @return {Step} The step corresponding to the `id`\n     */\n    ;\n\n    _proto.getById = function getById(id) {\n      return this.steps.find(function (step) {\n        return step.id === id;\n      });\n    }\n    /**\n     * Gets the current step\n     * @returns {Step|null}\n     */\n    ;\n\n    _proto.getCurrentStep = function getCurrentStep() {\n      return this.currentStep;\n    }\n    /**\n     * Hide the current step\n     */\n    ;\n\n    _proto.hide = function hide() {\n      var currentStep = this.getCurrentStep();\n\n      if (currentStep) {\n        return currentStep.hide();\n      }\n    }\n    /**\n     * Check if the tour is active\n     * @return {boolean}\n     */\n    ;\n\n    _proto.isActive = function isActive() {\n      return Shepherd.activeTour === this;\n    }\n    /**\n     * Go to the next step in the tour\n     * If we are at the end, call `complete`\n     */\n    ;\n\n    _proto.next = function next() {\n      var index = this.steps.indexOf(this.currentStep);\n\n      if (index === this.steps.length - 1) {\n        this.complete();\n      } else {\n        this.show(index + 1, true);\n      }\n    }\n    /**\n     * Removes the step from the tour\n     * @param {String} name The id for the step to remove\n     */\n    ;\n\n    _proto.removeStep = function removeStep(name) {\n      var _this3 = this;\n\n      var current = this.getCurrentStep(); // Find the step, destroy it and remove it from this.steps\n\n      this.steps.some(function (step, i) {\n        if (step.id === name) {\n          if (step.isOpen()) {\n            step.hide();\n          }\n\n          step.destroy();\n\n          _this3.steps.splice(i, 1);\n\n          return true;\n        }\n      });\n\n      if (current && current.id === name) {\n        this.currentStep = undefined; // If we have steps left, show the first one, otherwise just cancel the tour\n\n        this.steps.length ? this.show(0) : this.cancel();\n      }\n    }\n    /**\n     * Show a specific step in the tour\n     * @param {Number|String} key The key to look up the step by\n     * @param {Boolean} forward True if we are going forward, false if backward\n     */\n    ;\n\n    _proto.show = function show(key, forward) {\n      if (key === void 0) {\n        key = 0;\n      }\n\n      if (forward === void 0) {\n        forward = true;\n      }\n\n      var step = isString(key) ? this.getById(key) : this.steps[key];\n\n      if (step) {\n        this._updateStateBeforeShow();\n\n        var shouldSkipStep = isFunction(step.options.showOn) && !step.options.showOn(); // If `showOn` returns false, we want to skip the step, otherwise, show the step like normal\n\n        if (shouldSkipStep) {\n          this._skipStep(step, forward);\n        } else {\n          this.trigger('show', {\n            step: step,\n            previous: this.currentStep\n          });\n          this.currentStep = step;\n          step.show();\n        }\n      }\n    }\n    /**\n     * Start the tour\n     */\n    ;\n\n    _proto.start = function start() {\n      this.trigger('start'); // Save the focused element before the tour opens\n\n      this.focusedElBeforeOpen = document.activeElement;\n      this.currentStep = null;\n\n      this._setupModal();\n\n      this._setupActiveTour();\n\n      this.next();\n    }\n    /**\n     * Called whenever the tour is cancelled or completed, basically anytime we exit the tour\n     * @param {String} event The event name to trigger\n     * @private\n     */\n    ;\n\n    _proto._done = function _done(event) {\n      var index = this.steps.indexOf(this.currentStep);\n\n      if (Array.isArray(this.steps)) {\n        this.steps.forEach(function (step) {\n          return step.destroy();\n        });\n      }\n\n      cleanupSteps(this);\n      this.trigger(event, {\n        index: index\n      });\n      Shepherd.activeTour = null;\n      this.trigger('inactive', {\n        tour: this\n      });\n\n      if (this.modal) {\n        this.modal.hide();\n      }\n\n      if (event === 'cancel' || event === 'complete') {\n        if (this.modal) {\n          var modalContainer = document.querySelector('.shepherd-modal-overlay-container');\n\n          if (modalContainer) {\n            modalContainer.remove();\n          }\n        }\n      } // Focus the element that was focused before the tour started\n\n\n      if (isElement(this.focusedElBeforeOpen)) {\n        this.focusedElBeforeOpen.focus();\n      }\n    }\n    /**\n     * Make this tour \"active\"\n     * @private\n     */\n    ;\n\n    _proto._setupActiveTour = function _setupActiveTour() {\n      this.trigger('active', {\n        tour: this\n      });\n      Shepherd.activeTour = this;\n    }\n    /**\n     * _setupModal create the modal container and instance\n     * @private\n     */\n    ;\n\n    _proto._setupModal = function _setupModal() {\n      this.modal = new Shepherd_modal({\n        target: this.options.modalContainer || document.body,\n        props: {\n          classPrefix: this.classPrefix,\n          styles: this.styles\n        }\n      });\n    }\n    /**\n     * Called when `showOn` evaluates to false, to skip the step\n     * @param {Step} step The step to skip\n     * @param {Boolean} forward True if we are going forward, false if backward\n     * @private\n     */\n    ;\n\n    _proto._skipStep = function _skipStep(step, forward) {\n      var index = this.steps.indexOf(step);\n      var nextIndex = forward ? index + 1 : index - 1;\n      this.show(nextIndex, forward);\n    }\n    /**\n     * Before showing, hide the current step and if the tour is not\n     * already active, call `this._setupActiveTour`.\n     * @private\n     */\n    ;\n\n    _proto._updateStateBeforeShow = function _updateStateBeforeShow() {\n      if (this.currentStep) {\n        this.currentStep.hide();\n      }\n\n      if (!this.isActive()) {\n        this._setupActiveTour();\n      }\n    }\n    /**\n     * Sets this.id to `${tourName}--${uuid}`\n     * @private\n     */\n    ;\n\n    _proto._setTourID = function _setTourID() {\n      var tourName = this.options.tourName || 'tour';\n      this.id = tourName + \"--\" + uuid();\n    };\n\n    return Tour;\n  }(Evented);\n\n  Object.assign(Shepherd, {\n    Tour: Tour,\n    Step: Step\n  });\n  return Shepherd;\n});\n\n//# sourceURL=webpack:///./node_modules/shepherd.js/dist/js/shepherd.js?");

/***/ }),

/***/ "./wwwroot/vendor/libs/shepherd/shepherd.js":
/*!**************************************************!*\
  !*** ./wwwroot/vendor/libs/shepherd/shepherd.js ***!
  \**************************************************/
/*! exports provided: Shepherd */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var shepherd_js_dist_js_shepherd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shepherd.js/dist/js/shepherd.js */ \"./node_modules/shepherd.js/dist/js/shepherd.js\");\n/* harmony import */ var shepherd_js_dist_js_shepherd_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(shepherd_js_dist_js_shepherd_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"Shepherd\", function() { return shepherd_js_dist_js_shepherd_js__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./wwwroot/vendor/libs/shepherd/shepherd.js?");

/***/ })

/******/ })));